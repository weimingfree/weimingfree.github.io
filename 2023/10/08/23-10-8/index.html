<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>23.10.8 | experience sharing</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="数据结构练习">
<meta property="og:type" content="article">
<meta property="og:title" content="23.10.8">
<meta property="og:url" content="http://example.com/2023/10/08/23-10-8/index.html">
<meta property="og:site_name" content="experience sharing">
<meta property="og:description" content="数据结构练习">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-10-08T10:42:48.000Z">
<meta property="article:modified_time" content="2023-10-10T12:18:59.288Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="experience sharing" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">experience sharing</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">xu jian</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-23-10-8" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/10/08/23-10-8/" class="article-date">
  <time class="dt-published" datetime="2023-10-08T10:42:48.000Z" itemprop="datePublished">2023-10-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      23.10.8
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="数据结构练习"><a href="#数据结构练习" class="headerlink" title="数据结构练习"></a>数据结构练习</h1><span id="more"></span>

<h3 id="1-Parentheses-Balance"><a href="#1-Parentheses-Balance" class="headerlink" title="1.Parentheses Balance"></a>1.Parentheses Balance</h3><p>题目链接:<a target="_blank" rel="noopener" href="https://vjudge.net/problem/UVA-673">Parentheses Balance - UVA 673 - Virtual Judge (vjudge.net)</a></p>
<p>解析：如果这个序列它是正确的，那么它一定是满足栈的性质的</p>
<ul>
<li><p>如果是左括号，那么就压栈</p>
</li>
<li><p>右括号，如果栈为空，那么false</p>
<ul>
<li>如果碰到对应的左括号，消掉</li>
<li>如果没有碰到对应的左括号，false</li>
</ul>
</li>
<li><p>最后，栈是空的 true</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isRight</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">	stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">	_for(i,<span class="number">0</span>,s.<span class="built_in">size</span>())&#123;</span><br><span class="line">		<span class="type">char</span> c = s[i];</span><br><span class="line">		<span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span>)st.<span class="built_in">push</span>(c);</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(st.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			<span class="type">char</span> t = st.<span class="built_in">top</span>();</span><br><span class="line">			<span class="keyword">if</span>(c == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(t == <span class="string">&#x27;(&#x27;</span>)st.<span class="built_in">pop</span>();</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(t == <span class="string">&#x27;[&#x27;</span>)st.<span class="built_in">pop</span>();</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> st.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// streambuf *cinbuf = cin.rdbuf();</span></span><br><span class="line">	<span class="comment">// cin.rdbuf(input.rdbuf());</span></span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d\n&quot;</span>,&amp;n);</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">256</span>];</span><br><span class="line">	<span class="keyword">while</span>(n--)&#123;</span><br><span class="line">		<span class="built_in">gets</span>(buf);</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">isRight</span>(buf))output&lt;&lt;<span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> output&lt;&lt;<span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>如果buf用cin来输入，会造成空格被忽略的情况</li>
<li>如果n用cin输入，同样也会出错</li>
<li>用get的话，如果文件样例过大，输入会非常的慢</li>
</ul>
<h3 id="2-S-Trees"><a href="#2-S-Trees" class="headerlink" title="2.S-Trees"></a>2.S-Trees</h3><p>题目链接:<a target="_blank" rel="noopener" href="https://vjudge.net/problem/UVA-712">S-Trees - UVA 712 - Virtual Judge (vjudge.net)</a></p>
<p>解析:</p>
<ul>
<li>如果深度为n，那么将会有2^n个叶节点，记录叶节点时数组可能是比较大的</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n) == <span class="number">1</span> &amp;&amp; n)&#123;</span><br><span class="line">	leavesCnt = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">	_for(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,buf);</span><br><span class="line">		<span class="built_in">sscanf</span>(buf+<span class="number">1</span>,<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">		order[i] = x<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,buf);</span><br><span class="line">	_for(i,<span class="number">0</span>,leavesCnt)leaves[i] = buf[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">	output&lt;&lt;<span class="string">&quot;S-Tree #&quot;</span>&lt;&lt;t++&lt;&lt;<span class="string">&quot;:\n&quot;</span>;</span><br><span class="line">	_for(i,<span class="number">0</span>,m)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,buf);</span><br><span class="line">		output&lt;&lt;<span class="built_in">solve</span>(buf);</span><br><span class="line">	&#125;</span><br><span class="line">	output&lt;&lt;<span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将变量分配的顺序记录下来，即第i层应该去vva的哪一ix去取数</li>
<li>将所有的叶节点所对应的值记录下来</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* vva)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> l = <span class="number">0</span>,r = leavesCnt<span class="number">-1</span>;</span><br><span class="line">	_for(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">		<span class="type">int</span> o = order[i],m = (l+r)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(vva[o] == <span class="string">&#x27;1&#x27;</span>)l = m + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> r = m;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> leaves[l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据每一层的动向，缩小区间，最后就会正好得到该vva所对应的值。其实正是利用了二叉树的特性</p>
<h3 id="3-Tree-Recovery"><a href="#3-Tree-Recovery" class="headerlink" title="3.Tree Recovery"></a>3.Tree Recovery</h3><p>题目链接：<a target="_blank" rel="noopener" href="https://vjudge.net/problem/UVA-536">Tree Recovery - UVA 536 - Virtual Judge (vjudge.net)</a></p>
<p>根据二叉树的前序遍历和中序遍历得到后序遍历</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> PRE[<span class="number">30</span>],IN[<span class="number">30</span>];</span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> La,<span class="type">int</span> Ra,<span class="type">int</span> Lb,<span class="type">int</span> Rb)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(La &gt; Ra || Lb &gt; Rb)<span class="keyword">return</span>;</span><br><span class="line">	<span class="type">char</span> ch = PRE[La];</span><br><span class="line">	<span class="type">int</span> k;</span><br><span class="line">	<span class="keyword">for</span>(k = Lb;k &lt;= Ra &amp;&amp; IN[k] != ch;k++);</span><br><span class="line">	<span class="type">int</span> len = k -Lb;</span><br><span class="line">	<span class="built_in">build</span>(La+<span class="number">1</span>,La+len,Lb,k<span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">build</span>(La+len+<span class="number">1</span>,Ra,k+<span class="number">1</span>,Rb);</span><br><span class="line">	output&lt;&lt;ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// streambuf *cinbuf = cin.rdbuf();</span></span><br><span class="line">	<span class="comment">// cin.rdbuf(input.rdbuf());</span></span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,PRE,IN))&#123;</span><br><span class="line">		N = <span class="built_in">strlen</span>(PRE);</span><br><span class="line">		<span class="built_in">build</span>(<span class="number">0</span>,N<span class="number">-1</span>,<span class="number">0</span>,N<span class="number">-1</span>);</span><br><span class="line">		output&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>递归，注意递归的结束条件，递归调用的顺序</li>
<li>这里k为什么要小于等于Ra和小于等于Rb有什么区别呢？</li>
<li>找到根节点在中序序列中的ix，根据ix可以得到左子树的长度，然后分别对左右子树进行递归</li>
<li>其实子递归一共需要8个参数，而函数参数可以提供4个，通过根节点在中序的ix又可以直接提供两个，通过ix得到左子树的长度又可以提供两个</li>
</ul>
<h3 id="4-Knight-Moves"><a href="#4-Knight-Moves" class="headerlink" title="4.Knight Moves"></a>4.Knight Moves</h3><p>题目链接:<a target="_blank" rel="noopener" href="https://vjudge.net/problem/UVA-439">Knight Moves - UVA 439 - Virtual Judge (vjudge.net)</a></p>
<p>1.一些初始的工作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="built_in">Point</span>(<span class="type">int</span> x = <span class="number">0</span>,<span class="type">int</span> y = <span class="number">0</span>):<span class="built_in">x</span>(x),<span class="built_in">y</span>(y)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Point <span class="keyword">operator</span>+(<span class="type">const</span> Point&amp; A,<span class="type">const</span> Point&amp; B)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Point</span>(A.x+B.x,A.y+B.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Point&amp; a,<span class="type">const</span> Point&amp; b)&#123;</span><br><span class="line">	<span class="keyword">return</span> a.x == b.x &amp;&amp;  a.y == b.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">inRange</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(left &gt; right)<span class="keyword">return</span> <span class="built_in">inRange</span>(x,right,left);</span><br><span class="line">	<span class="keyword">return</span> left &lt;= x &amp;&amp; x &lt;= right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Point <span class="title">toPoint</span><span class="params">(<span class="type">const</span> string&amp; ps)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Point</span>(ps[<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span>,ps[<span class="number">1</span>]-<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">8</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(<span class="type">const</span> Point&amp; p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">inRange</span>(p.x,<span class="number">0</span>,N<span class="number">-1</span>) &amp;&amp; <span class="built_in">inRange</span>(p.y,<span class="number">0</span>,N<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">Point dir[N] = &#123;&#123;<span class="number">2</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">-2</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-2</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">-2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">-2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">-1</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>习题的作者经常将非常小的功能也单独写出来，这和竞赛选手是不太相同的</li>
<li>这里Point.x并不是行而是列，但对题目是没有影响的</li>
</ul>
<p>2.bfs</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">const</span> Point&amp; a,<span class="type">const</span> Point&amp; b)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> vis[N][N];</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">-1</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">	queue&lt;Point&gt; q;</span><br><span class="line">	q.<span class="built_in">push</span>(a);</span><br><span class="line">	vis[a.x][a.y] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">const</span> Point&amp; f = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="type">int</span> d  = vis[f.x][f.y];</span><br><span class="line">		<span class="keyword">if</span>(f == b)<span class="keyword">return</span> d;</span><br><span class="line">		_for(i,<span class="number">0</span>,N)&#123;</span><br><span class="line">			Point np = f + dir[i];</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">isValid</span>(np) &amp;&amp; vis[np.x][np.y] == <span class="number">-1</span>)&#123;</span><br><span class="line">				vis[np.x][np.y] = d+<span class="number">1</span>;</span><br><span class="line">				q.<span class="built_in">push</span>(np);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意下一点有效的情况是本来没有被访问并且点在棋盘的内部</li>
</ul>
<h3 id="5-Patrol-Robot"><a href="#5-Patrol-Robot" class="headerlink" title="5.Patrol Robot"></a>5.Patrol Robot</h3><p>题目链接:<a target="_blank" rel="noopener" href="https://vjudge.net/problem/UVA-1600">Patrol Robot - UVA 1600 - Virtual Judge (vjudge.net)</a></p>
<p>1.这道题和上一道题是类似的，因此数据结构也是类似的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">21</span>;</span><br><span class="line"><span class="type">int</span> M,N,K,Grid[MAX][MAX],vis[MAX][MAX][MAX];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="built_in">Point</span>(<span class="type">int</span> x = <span class="number">0</span>,<span class="type">int</span> y = <span class="number">0</span>):<span class="built_in">x</span>(x),<span class="built_in">y</span>(y)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Point <span class="keyword">operator</span>+(<span class="type">const</span> Point&amp; A,<span class="type">const</span> Point&amp; B)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Point</span>(A.x+B.x,A.y+B.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Point&amp; a,<span class="type">const</span> Point&amp; b)&#123;</span><br><span class="line">	<span class="keyword">return</span> a.x == b.x &amp;&amp;  a.y == b.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">inRange</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(left &gt; right)<span class="keyword">return</span> <span class="built_in">inRange</span>(x,right,left);</span><br><span class="line">	<span class="keyword">return</span> left &lt;= x &amp;&amp; x &lt;= right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(<span class="type">const</span> Point&amp; p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">inRange</span>(p.x,<span class="number">0</span>,M<span class="number">-1</span>) &amp;&amp; <span class="built_in">inRange</span>(p.y,<span class="number">0</span>,N<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Stat</span>&#123;</span><br><span class="line">	Point pos;</span><br><span class="line">	<span class="type">int</span> turbo;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">getVised</span><span class="params">(<span class="type">const</span> Stat&amp; s)</span></span>&#123;<span class="keyword">return</span> vis[s.pos.x][s.pos.y][s.turbo];&#125;</span><br><span class="line">Point dir[<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>此题的vis设置成了三维的，为了应对涡轮模式，其实按照往常思路来说，如果碰到了原来的点，也不能说不要这个点，因为原来的点的涡轮模式可能是0，而现在的涡轮模式可能是1个比较大的数</li>
<li>就连查询vis数组内的值也包装成一个函数，为了方便</li>
</ul>
<p>2.bfs</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Stat s;</span><br><span class="line">	<span class="function">Point <span class="title">dest</span><span class="params">(M<span class="number">-1</span>,N<span class="number">-1</span>)</span></span>;</span><br><span class="line">	s.pos.x = <span class="number">0</span>,s.pos.y = <span class="number">0</span>,s.turbo =<span class="number">0</span> ;</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">-1</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">	queue&lt;Stat&gt;q;</span><br><span class="line">	q.<span class="built_in">push</span>(s);</span><br><span class="line">	vis[s.pos.x][s.pos.y][s.turbo] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">const</span> Stat&amp; f = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="type">const</span> <span class="type">int</span>&amp; fd = <span class="built_in">getVised</span>(f);</span><br><span class="line">		<span class="keyword">if</span>(f.pos == dest) <span class="keyword">return</span> fd;</span><br><span class="line">		_for(i,<span class="number">0</span>,<span class="number">4</span>)&#123;</span><br><span class="line">			Point np = f.pos + dir[i];</span><br><span class="line">			<span class="keyword">if</span>(!<span class="built_in">isValid</span>(np))<span class="keyword">continue</span>;</span><br><span class="line">			<span class="type">int</span> isBlock = Grid[np.x][np.y];</span><br><span class="line">			<span class="keyword">if</span>(isBlock &amp;&amp; f.turbo + <span class="number">1</span> &gt; K)<span class="keyword">continue</span>;</span><br><span class="line">			Stat ns;</span><br><span class="line">			ns.pos = np;</span><br><span class="line">			ns.turbo = isBlock ?(f.turbo+<span class="number">1</span>):<span class="number">0</span>;</span><br><span class="line">			<span class="type">int</span>&amp; d = <span class="built_in">getVised</span>(ns);</span><br><span class="line">			<span class="keyword">if</span>(d == <span class="number">-1</span>)&#123;</span><br><span class="line">				d = fd+<span class="number">1</span>;</span><br><span class="line">				q.<span class="built_in">push</span>(ns);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先应该判断点的位置是否相等</li>
<li>按照自然逻辑来说，距离应该是到达之后再进行更新，但按照这个作者的风格一般都是能提前更新绝不推后</li>
<li>而且在判断下一个位置是否合法的时候，先判断下一个点的位置和涡轮是否合法，如果合法再生成下一个Stat，对Stat的pos和turbo进行更新，如果该Stat是新的状态，再对此Stat的vis进行更新，然后压栈</li>
<li>关于Stat的turbo的更新，通过新的位置是否是障碍物，来对涡轮清零或者加1</li>
<li>关于更新vis值，使用了int&amp;，这样对int&amp;更改就是对原值进行修改</li>
</ul>
<h3 id="6-Equilibrium-Mobile"><a href="#6-Equilibrium-Mobile" class="headerlink" title="6.Equilibrium Mobile"></a>6.Equilibrium Mobile</h3><p>题目链接:<a target="_blank" rel="noopener" href="https://vjudge.net/problem/UVA-12166">Equilibrium Mobile - UVA 12166 - Virtual Judge (vjudge.net)</a></p>
<p>解析：</p>
<p>首先我们要明白一点，假如一个节点是最后二叉平衡树的一个节点，那么这个节点的重量*2^(该节点所在的层数，根节点在第0层) &#x3D; 整个二叉树的重量；所以我们可以对每个节点求对应二叉树的重量，可以通过map得到每个重量对应多少个节点，对应节点个数最多的重量就是change最少节点可以得到的重量，那么用总结点去减去该节点就是需要修改的节点数目</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> T;</span><br><span class="line">	cin&gt;&gt;T;</span><br><span class="line">	string line;</span><br><span class="line">	map&lt;<span class="type">long</span> <span class="type">long</span>,<span class="type">int</span>&gt;mp;</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		cin&gt;&gt;line;</span><br><span class="line">		mp.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>,codeC = <span class="number">0</span>;</span><br><span class="line">        _for(i,<span class="number">0</span>,line.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="type">char</span> c = line[i];</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;[&#x27;</span>)depth++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;]&#x27;</span>)depth--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isdight</span>(c))&#123;</span><br><span class="line">				<span class="type">long</span> <span class="type">long</span> v = c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                  <span class="type">int</span> j;</span><br><span class="line">                  <span class="keyword">for</span>(j = i+<span class="number">1</span>;j &lt; line.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isdight</span>(j);j++)&#123;</span><br><span class="line">                      v *= <span class="number">10</span>;</span><br><span class="line">                      v += line[j] -<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">                  i = j<span class="number">-1</span>;</span><br><span class="line">                  v &lt;&lt;= depth;</span><br><span class="line">                  mp[v]++;</span><br><span class="line">                  nodeC++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> K = <span class="number">-1</span>;</span><br><span class="line">	    <span class="keyword">for</span>(<span class="keyword">auto</span> p : mp)K = <span class="built_in">max</span>(K,p.second);</span><br><span class="line">		output&lt;&lt;(nodeC-K)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在字符串中得到数的操作还是比较经典的</li>
<li>关于二叉树的层数怎么表示能想到吗？</li>
</ul>
<h3 id="7-Petri-Net-Simulation"><a href="#7-Petri-Net-Simulation" class="headerlink" title="7.Petri Net Simulation"></a>7.Petri Net Simulation</h3><p>链接:<a target="_blank" rel="noopener" href="https://vjudge.net/problem/UVA-804">Petri Net Simulation - UVA 804 - Virtual Judge (vjudge.net)</a></p>
<p>1.数据结构</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;places;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Transition</span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;output;	</span><br><span class="line">	map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;input;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">enabled</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;p :input)<span class="keyword">if</span>(places[p.first] &lt; p.second)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">		input.<span class="built_in">clear</span>(),output.<span class="built_in">clear</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">op</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;p : input)places[p.first] -=p.second;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;o : output)places[o]++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Transition&gt;ts;</span><br></pre></td></tr></table></figure>

<ul>
<li>输出用vector，而输入用map是因为一个输入可能要输入多次，而一个输出最多使用1次</li>
<li>什么情况下是live的呢？即每个输入的token必须要大于等于其本身输入的次数</li>
<li>每一次fire，每一个输入中的token都会根据它被输出的次数减掉相应的token，而每一个输出中的token都会+1</li>
</ul>
<p>2.主函数运行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// streambuf *cinbuf = cin.rdbuf();</span></span><br><span class="line">	<span class="comment">// cin.rdbuf(input.rdbuf());</span></span><br><span class="line">	<span class="type">int</span> NP;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> kase = <span class="number">1</span>;cin&gt;&gt;NP &amp;&amp; NP;kase++)&#123;</span><br><span class="line">		places.<span class="built_in">clear</span>();ts.<span class="built_in">clear</span>();</span><br><span class="line">		_for(i,<span class="number">0</span>,NP)places.<span class="built_in">push_back</span>(<span class="built_in">readInt</span>());</span><br><span class="line">		<span class="type">int</span> NT = <span class="built_in">readInt</span>();</span><br><span class="line">		Transition t;</span><br><span class="line">		_for(i,<span class="number">0</span>,NT)&#123;</span><br><span class="line">			t.<span class="built_in">init</span>();</span><br><span class="line">			<span class="type">int</span> x;</span><br><span class="line">			<span class="keyword">while</span>(cin&gt;&gt;x &amp;&amp; x)&#123;</span><br><span class="line">				<span class="keyword">if</span>(x &lt; <span class="number">0</span>)t.input[-x<span class="number">-1</span>]++;</span><br><span class="line">				<span class="keyword">else</span> t.output.<span class="built_in">push_back</span>(x<span class="number">-1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			ts.<span class="built_in">push_back</span>(t);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">bool</span> live = <span class="literal">true</span>;<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> NF = <span class="built_in">readInt</span>();</span><br><span class="line">		_for(i,<span class="number">0</span>,NF)&#123;</span><br><span class="line">			<span class="keyword">auto</span> pt = <span class="built_in">find_if</span>(ts.<span class="built_in">begin</span>(),ts.<span class="built_in">end</span>(),[](<span class="type">const</span> Transition&amp; t)&#123;<span class="keyword">return</span> t.<span class="built_in">enabled</span>();&#125;);</span><br><span class="line">			live = pt != ts.<span class="built_in">end</span>();</span><br><span class="line">			<span class="keyword">if</span>(!live)<span class="keyword">break</span>;</span><br><span class="line">			pt-&gt;<span class="built_in">op</span>();</span><br><span class="line">			cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">		output&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;kase&lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">		<span class="keyword">if</span>(live)output&lt;&lt;<span class="string">&quot;still live after &quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> output&lt;&lt;<span class="string">&quot;dead after &quot;</span>;</span><br><span class="line">		output&lt;&lt;cnt&lt;&lt;<span class="string">&quot; transitions\nPlaces with tokens:&quot;</span>;</span><br><span class="line">		_for(i,<span class="number">0</span>,places.<span class="built_in">size</span>())&#123;</span><br><span class="line">			<span class="type">int</span> t = places[i];</span><br><span class="line">			<span class="keyword">if</span>(t)output&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot; (&quot;</span>&lt;&lt;t&lt;&lt;<span class="string">&quot;)&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		output&lt;&lt;<span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>输入每个place中的token数目，建立起每个transition对象（因为输入是用负数，所以要取相反数处理）</li>
<li>关于模拟run<ul>
<li>auto pt &#x3D; find_if(ts.begin(),ts.end(),[](const Transition&amp; t){return t.enabled();});头两个参数给予范围，后一个匿名谓词函数则检查该transition是否可运行，然后会返回第一个live的transition</li>
<li>一次run只需要fire一个transition，无论哪一个，题目中保证无论哪一个fire都不影响最终的结果</li>
<li>如果没有一个enable的，那么就说整个就是死掉的</li>
</ul>
</li>
</ul>
<h3 id="8-Spatial-Structures"><a href="#8-Spatial-Structures" class="headerlink" title="8.Spatial Structures"></a>8.Spatial Structures</h3><p>题目链接:</p>
<p><a target="_blank" rel="noopener" href="https://vjudge.net/problem/UVA-806">Spatial Structures - UVA 806 - Virtual Judge (vjudge.net)</a></p>
<p>解析：没有去运用繁杂的数据结构，比如四叉树，使用了比较精简的代码（竞赛风格）</p>
<p>1.主函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> kase = <span class="number">1</span>; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N) == <span class="number">1</span> &amp;&amp; N; kase++) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (kase &gt; <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;Image %d\n&quot;</span>, kase);</span><br><span class="line">    	<span class="keyword">if</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      		_for(i, <span class="number">0</span>, N) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, IMG[i]);</span><br><span class="line">      		vector&lt;<span class="type">int</span>&gt; blacks;</span><br><span class="line">      		<span class="built_in">countBlack</span>(<span class="number">0</span>, <span class="number">0</span>, N, blacks);</span><br><span class="line">      		<span class="built_in">sort</span>(<span class="built_in">begin</span>(blacks), <span class="built_in">end</span>(blacks));</span><br><span class="line">      		<span class="type">int</span> sz = blacks.<span class="built_in">size</span>();</span><br><span class="line">      		_for(i, <span class="number">0</span>, sz) <span class="built_in">printf</span>(<span class="string">&quot;%d%s&quot;</span>, blacks[i], (i % <span class="number">12</span> == <span class="number">11</span> || i == sz - <span class="number">1</span>) ? <span class="string">&quot;\n&quot;</span> : <span class="string">&quot; &quot;</span>);</span><br><span class="line">      		<span class="built_in">printf</span>(<span class="string">&quot;Total number of black nodes = %d\n&quot;</span>, sz);</span><br><span class="line">    	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      		<span class="type">int</span> p;</span><br><span class="line">      		<span class="built_in">memset</span>(IMG, <span class="number">0</span>, <span class="built_in">sizeof</span>(IMG));</span><br><span class="line">      		N = -N;</span><br><span class="line">      		_for(i, <span class="number">0</span>, N) _for(j, <span class="number">0</span>, N) IMG[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">      		<span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p) == <span class="number">1</span> &amp;&amp; p &gt;= <span class="number">0</span>) <span class="built_in">draw</span>(p, <span class="number">0</span>, <span class="number">0</span>, N);</span><br><span class="line">      		_for(i, <span class="number">0</span>, N) <span class="built_in">puts</span>(IMG[i]);</span><br><span class="line">    	&#125;</span><br><span class="line">  	&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>主要注意输入输出格式的正确性<ul>
<li>比如说在一个图片与图片之间要有空格</li>
<li>在输出root-to-leaf时，每12个为一line，每一个number后跟空格或换行</li>
</ul>
</li>
</ul>
<p>2.构建root-to-leaf函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">countBlack</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> len,vector&lt;<span class="type">int</span>&gt;&amp; ans,<span class="type">int</span> path = <span class="number">0</span>,<span class="type">int</span> p5 = <span class="number">1</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> f = <span class="number">0</span>,len2 = len/<span class="number">2</span>;</span><br><span class="line">	_for(i,x,x+len)</span><br><span class="line">		_for(j,y,y+len)</span><br><span class="line">			f+=IMG[i][j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span>(f == <span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(f == len*len)&#123;</span><br><span class="line">		ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	_for(di,<span class="number">0</span>,<span class="number">4</span>)&#123;</span><br><span class="line">		<span class="built_in">countBlack</span>(x+DX[di]*len2,y+DY[di]*len2,len2,ans,path+p5*(di+<span class="number">1</span>),p5*<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>递归终止条件，如果这块区域的所有pixel之和为0，不需要计算，如果这块区域的每个pixel的值都是1，就可以将path push 进ans之中</li>
<li>关于path值的计算，其实题目中没有说出，每缩小一层，path就会在原来的基础上+dir*<em>base,同时base每下一层都要</em>5</li>
</ul>
<p>3.构建image的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">int</span> path,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(path == <span class="number">0</span>)&#123;</span><br><span class="line">		_for(i,x,x+len)</span><br><span class="line">			_for(j,y,y+len)</span><br><span class="line">				IMG[i][j] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> di = path%<span class="number">5</span><span class="number">-1</span>,len2 = len/<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">draw</span>(path/<span class="number">5</span>,x+DX[di]*len2,y+DY[di]*len2,len2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果到了这片区域其path为0，那么说明全部是黑的，那么直接打印就可以了</li>
<li>主要是根据现有的path去推断哪篇区域全部是黑格有些困难<ul>
<li>只能说根据公式倒推，得知下一层的方向是path%5，下一层的path再&#x2F;&#x3D;5，其实对于每一层来说path代表什么？path代表0表示这一层全是黑的，否则不是</li>
<li>我觉得应该是更下面所有层的dir*base之和</li>
</ul>
</li>
</ul>
<h3 id="9-”Accordian”-Patience"><a href="#9-”Accordian”-Patience" class="headerlink" title="9.”Accordian” Patience"></a>9.”Accordian” Patience</h3><p>题目链接:<a target="_blank" rel="noopener" href="https://vjudge.net/problem/UVA-127">“Accordian” Patience - UVA 127 - Virtual Judge (vjudge.net)</a></p>
<p>解析:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> PileCnt = <span class="number">52</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Card</span>&#123;</span><br><span class="line">	<span class="type">char</span> suit,rank;</span><br><span class="line">	<span class="built_in">Card</span>(<span class="type">char</span> r,<span class="type">char</span> s):<span class="built_in">suit</span>(s),<span class="built_in">rank</span>(r)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">match</span><span class="params">(<span class="type">const</span> Card&amp; a)</span><span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> rank == a.rank || suit == a.suit;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pile</span>&#123;</span><br><span class="line">	stack&lt;Card&gt; cards;</span><br><span class="line">	Pile *prev,*next;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(!cards.<span class="built_in">empty</span>())cards.<span class="built_in">pop</span>();</span><br><span class="line">		prev = <span class="literal">nullptr</span>;next = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Pile piles[<span class="number">1</span>+PileCnt],*head;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">connect</span><span class="params">(Pile* p1,Pile* p2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p1)p1-&gt;next = p2;</span><br><span class="line">	<span class="keyword">if</span>(p2)p2-&gt;prev = p1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Pile* <span class="title">getLeft3</span><span class="params">(Pile* p)</span></span>&#123;</span><br><span class="line">	_for(i,<span class="number">0</span>,<span class="number">3</span>)&#123;</span><br><span class="line">		p = p-&gt;prev;</span><br><span class="line">		<span class="keyword">if</span>(p == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>值得注意的是Pile.init()，看来stack没有clear()，所以才要一个一个的pop()</li>
<li>注意如何将两个Pile相连接，以及如何得到左前第三个Pile</li>
</ul>
<ol start="2">
<li></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// streambuf *cinbuf = cin.rdbuf();</span></span><br><span class="line">	<span class="comment">// cin.rdbuf(input.rdbuf());</span></span><br><span class="line">	string s;</span><br><span class="line">	<span class="type">bool</span> end = <span class="literal">false</span>;</span><br><span class="line">	head = &amp;(piles[<span class="number">0</span>]);</span><br><span class="line">	head-&gt;<span class="built_in">init</span>();</span><br><span class="line">	head-&gt;next = &amp;(piles[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i &lt;= PileCnt;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(cin&gt;&gt;s &amp;&amp; s.<span class="built_in">size</span>() == <span class="number">2</span>)&#123;</span><br><span class="line">				Pile&amp; p = piles[i];</span><br><span class="line">				p.<span class="built_in">init</span>();</span><br><span class="line">				p.prev = &amp;(piles[i<span class="number">-1</span>]);</span><br><span class="line">				<span class="keyword">if</span>(i+<span class="number">1</span> &lt;= PileCnt)p.next = &amp;(piles[i+<span class="number">1</span>]);</span><br><span class="line">				p.cards.<span class="built_in">push</span>(<span class="built_in">Card</span>(s[<span class="number">0</span>],s[<span class="number">1</span>]));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">solve</span>();</span><br><span class="line">		Pile *cur = head-&gt;next;</span><br><span class="line">		vector&lt;<span class="type">int</span>&gt; ps;</span><br><span class="line">		<span class="keyword">while</span>(cur)&#123;</span><br><span class="line">			ps.<span class="built_in">push_back</span>(cur-&gt;cards.<span class="built_in">size</span>());</span><br><span class="line">			cur = cur-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		output&lt;&lt;ps.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot; pile&quot;</span>&lt;&lt;(ps.<span class="built_in">size</span>() &gt; <span class="number">1</span> ? <span class="string">&quot;s&quot;</span> : <span class="string">&quot;&quot;</span>)&lt;&lt;<span class="string">&quot; remaining:&quot;</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> i = ps.<span class="built_in">begin</span>();i != ps.<span class="built_in">end</span>();i++)&#123;</span><br><span class="line">			output&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;*i;</span><br><span class="line">		&#125;</span><br><span class="line">		output&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>初始化，init每一个Pile，初始化其Card值，连接prev,next，将Card压入Pile</li>
<li>在链表中经常有建立一个空的头节点的情况</li>
<li>遍历链表，记录答案</li>
</ul>
<ol start="3">
<li></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Pile* from,*to,*cur;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">		from = <span class="literal">nullptr</span>,to = <span class="literal">nullptr</span>;</span><br><span class="line">		cur = head-&gt;next;</span><br><span class="line">		<span class="keyword">while</span>(cur)&#123;</span><br><span class="line">			Pile* l3 = <span class="built_in">getLeft3</span>(cur);</span><br><span class="line">			<span class="keyword">if</span>(l3 != <span class="literal">nullptr</span> &amp;&amp; l3 != head)&#123;</span><br><span class="line">				<span class="keyword">if</span>(l3 -&gt;cards.<span class="built_in">top</span>().<span class="built_in">match</span>(cur-&gt;cards.<span class="built_in">top</span>()))&#123;</span><br><span class="line">					from = cur;to = l3;<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			Pile* l1 = cur-&gt;prev;</span><br><span class="line">			<span class="keyword">if</span>(l1 != head)&#123;</span><br><span class="line">				<span class="keyword">if</span>(l1 -&gt;cards.<span class="built_in">top</span>().<span class="built_in">match</span>(cur-&gt;cards.<span class="built_in">top</span>()))&#123;</span><br><span class="line">					from = cur;to = l1;<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			cur = cur-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!from)<span class="keyword">break</span>;</span><br><span class="line">		to-&gt;cards.<span class="built_in">push</span>(from-&gt;cards.<span class="built_in">top</span>());</span><br><span class="line">		from-&gt;cards.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(from-&gt;cards.<span class="built_in">empty</span>())<span class="built_in">connect</span>(from-&gt;prev,from-&gt;next);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>何时结束：没有找到转移卡牌的堆</li>
<li>一次game最多转移一个卡牌，找到一个符合条件的就break，剩下的等待下一次</li>
<li>注意链表的边界条件</li>
</ul>
<h3 id="10-10-20-30"><a href="#10-10-20-30" class="headerlink" title="10.10-20-30"></a>10.10-20-30</h3><p>题目链接:<a target="_blank" rel="noopener" href="https://vjudge.net/problem/UVA-246">10-20-30 - UVA 246 - Virtual Judge (vjudge.net)</a></p>
<ol>
<li></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> CN = <span class="number">52</span>;</span><br><span class="line"><span class="keyword">typedef</span> deque&lt;<span class="type">int</span>&gt;Pile;</span><br><span class="line">Pile cards;</span><br><span class="line">Pile allPiles[<span class="number">7</span>];</span><br><span class="line">list&lt;Pile*&gt; piles;</span><br><span class="line">set&lt;string&gt; phases;</span><br></pre></td></tr></table></figure>

<ul>
<li>set用来判重，deque用来存手中的牌和堆中的牌,list用来模拟轮转发牌模式</li>
</ul>
<ol start="2">
<li></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// streambuf *cinbuf = cin.rdbuf();</span></span><br><span class="line">	<span class="comment">// cin.rdbuf(input.rdbuf());</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">		cards.<span class="built_in">clear</span>(),piles.<span class="built_in">clear</span>(),phases.<span class="built_in">clear</span>();</span><br><span class="line">		_for(i,<span class="number">0</span>,CN)&#123;</span><br><span class="line">			<span class="type">int</span> c;cin&gt;&gt;c;</span><br><span class="line">			<span class="keyword">if</span>(c == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			cards.<span class="built_in">push_back</span>(c);</span><br><span class="line">		&#125;</span><br><span class="line">		_for(i,<span class="number">0</span>,<span class="number">7</span>)&#123;</span><br><span class="line">			Pile&amp; p = allPiles[i];</span><br><span class="line">			p.<span class="built_in">clear</span>(),p.<span class="built_in">push_back</span>(cards.<span class="built_in">front</span>());</span><br><span class="line">			cards.<span class="built_in">pop_front</span>();</span><br><span class="line">			piles.<span class="built_in">push_back</span>(&amp;p);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> t = <span class="number">7</span>;</span><br><span class="line">		<span class="keyword">while</span>(<span class="literal">true</span>)<span class="keyword">if</span>(!<span class="built_in">simulate</span>(t++))<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>初始化手中的牌，每一堆先发一张牌，并且进入轮转模拟list中，模拟</li>
</ul>
<ol start="3">
<li></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">encode</span><span class="params">(string&amp; ans)</span></span>&#123;</span><br><span class="line">	ans.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; pp : piles)&#123;</span><br><span class="line">		Pile&amp; p = *pp;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> c : p)ans += (<span class="type">char</span>)c;</span><br><span class="line">		ans += <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> c :cards)ans += (<span class="type">char</span>)c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">procPile</span><span class="params">(Pile&amp; p)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n = p.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span>(n &lt; <span class="number">3</span>)<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>((p[<span class="number">0</span>]+p[<span class="number">1</span>]+p.<span class="built_in">back</span>())%<span class="number">10</span> == <span class="number">0</span>)&#123;</span><br><span class="line">		cards.<span class="built_in">push_back</span>(p[<span class="number">0</span>]),</span><br><span class="line">		cards.<span class="built_in">push_back</span>(p[<span class="number">1</span>]),</span><br><span class="line">		cards.<span class="built_in">push_back</span>(p.<span class="built_in">back</span>());</span><br><span class="line">		p.<span class="built_in">pop_front</span>(),</span><br><span class="line">		p.<span class="built_in">pop_front</span>(),</span><br><span class="line">		p.<span class="built_in">pop_back</span>(),</span><br><span class="line">		<span class="built_in">procPile</span>(p);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>((p[<span class="number">0</span>]+p[n<span class="number">-2</span>]+p[n<span class="number">-1</span>])%<span class="number">10</span> == <span class="number">0</span>)&#123;</span><br><span class="line">		cards.<span class="built_in">push_back</span>(p[<span class="number">0</span>]),</span><br><span class="line">		cards.<span class="built_in">push_back</span>(p[n<span class="number">-2</span>]),</span><br><span class="line">		cards.<span class="built_in">push_back</span>(p[n<span class="number">-1</span>]);</span><br><span class="line">		p.<span class="built_in">pop_front</span>(),</span><br><span class="line">		p.<span class="built_in">pop_back</span>(),</span><br><span class="line">		p.<span class="built_in">pop_back</span>(),</span><br><span class="line">		<span class="built_in">procPile</span>(p);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>((p[n<span class="number">-3</span>]+p[n<span class="number">-2</span>]+p[n<span class="number">-1</span>])%<span class="number">10</span> == <span class="number">0</span>)&#123;</span><br><span class="line">		cards.<span class="built_in">push_back</span>(p[n<span class="number">-3</span>]),</span><br><span class="line">		cards.<span class="built_in">push_back</span>(p[n<span class="number">-2</span>]),</span><br><span class="line">		cards.<span class="built_in">push_back</span>(p[n<span class="number">-1</span>]);</span><br><span class="line">		p.<span class="built_in">pop_back</span>(),</span><br><span class="line">		p.<span class="built_in">pop_back</span>(),</span><br><span class="line">		p.<span class="built_in">pop_back</span>(),</span><br><span class="line">		<span class="built_in">procPile</span>(p);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>关于编码，这是一个将手中牌和堆中牌状态全部记录下来并且进行编码，为了严谨堆与堆之间还加上’|’;</li>
<li>关于取数，要注意card.push_back()的顺序；以及和是10，20，30可以用是10的倍数来解决（因为3张牌和最多就是30）</li>
<li>蕴含着一种递归思想</li>
</ul>
<ol start="4">
<li></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">simulate</span><span class="params">(<span class="type">int</span> time)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(piles.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		output&lt;&lt;<span class="string">&quot;Win : &quot;</span>&lt;&lt;time&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cards.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		output&lt;&lt;<span class="string">&quot;Loss: &quot;</span>&lt;&lt;time&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	string pha;</span><br><span class="line">	<span class="built_in">encode</span>(pha);</span><br><span class="line">	<span class="keyword">if</span>(phases.<span class="built_in">count</span>(pha))&#123;</span><br><span class="line">		output&lt;&lt;<span class="string">&quot;Draw: &quot;</span>&lt;&lt;time&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> phases.<span class="built_in">insert</span>(pha);</span><br><span class="line">	<span class="type">int</span> c = cards.<span class="built_in">front</span>();</span><br><span class="line">	cards.<span class="built_in">pop_front</span>();</span><br><span class="line">	piles.<span class="built_in">push_back</span>(piles.<span class="built_in">front</span>());</span><br><span class="line">	piles.<span class="built_in">pop_front</span>();</span><br><span class="line">	Pile&amp; p = *(piles.<span class="built_in">back</span>());</span><br><span class="line">	p.<span class="built_in">push_back</span>(c);</span><br><span class="line">	<span class="built_in">procPile</span>(p);</span><br><span class="line">	<span class="keyword">if</span>(p.<span class="built_in">empty</span>())piles.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>每轮模拟一次发牌的过程</li>
<li>如果堆全为空，手中牌全为空，牌的状态有重的，那么模拟结束</li>
<li>否则就进行发牌模拟</li>
<li>其中发给哪一个堆，用一个list进行模拟，每次将表头转到表尾进行模拟，如果这个堆模拟完是空的，就从堆中删去</li>
</ul>
<h3 id="11-Tree-Reconstruction"><a href="#11-Tree-Reconstruction" class="headerlink" title="11.Tree Reconstruction"></a>11.Tree Reconstruction</h3><p>题目链接：<a target="_blank" rel="noopener" href="https://vjudge.net/problem/UVA-10410#google_vignette">Tree Reconstruction - UVA 10410 - Virtual Judge (vjudge.net)</a></p>
<p>解析:</p>
<ol>
<li></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(cin&gt;&gt;n &amp;&amp; n)&#123;</span><br><span class="line">		BFS.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">			G[i].<span class="built_in">clear</span>();</span><br><span class="line">			sub_dfs[i].<span class="built_in">clear</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		_for(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">			<span class="type">int</span> x;cin&gt;&gt;x;</span><br><span class="line">			BFS.<span class="built_in">push_back</span>(x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> x;</span><br><span class="line">		cin&gt;&gt;x;</span><br><span class="line">		_for(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">			cin&gt;&gt;x;</span><br><span class="line">			sub_dfs[BFS[<span class="number">0</span>]].<span class="built_in">push_back</span>(x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> bi = <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(BFS[<span class="number">0</span>],bi);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">			<span class="built_in">sort</span>(G[i].<span class="built_in">begin</span>(),G[i].<span class="built_in">end</span>());</span><br><span class="line">			output&lt;&lt;i&lt;&lt;<span class="string">&quot;:&quot;</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> p : G[i])output&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;p;</span><br><span class="line">			output&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>存储了BFS序列，存储了第一个节点（根节点）的DFS序列，我们还可以看到G中存储着最终的答案</li>
</ul>
<ol start="2">
<li></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span>&amp; bi)</span></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="keyword">auto</span>&amp; uDfs = sub_dfs[u];</span><br><span class="line">	<span class="type">int</span> sz = uDfs.<span class="built_in">size</span>(),i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i &lt; sz)&#123;</span><br><span class="line">		<span class="type">int</span> v = uDfs[i];</span><br><span class="line">		<span class="keyword">if</span>(bi &lt; n &amp;&amp; BFS[bi] == v)&#123;</span><br><span class="line">			root[v] = u;G[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">			bi++;i++;</span><br><span class="line">			<span class="keyword">while</span>(bi &lt; n &amp;&amp; i &lt; sz)&#123;</span><br><span class="line">				<span class="type">int</span> vv =uDfs[i];</span><br><span class="line">				<span class="keyword">if</span>(BFS[bi] == vv)<span class="keyword">break</span>;</span><br><span class="line">				sub_dfs[v].<span class="built_in">push_back</span>(vv);root[vv] = v;i++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(bi &lt;n)<span class="built_in">dfs</span>(root[BFS[bi]],bi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先bi指的是BFS中ix为bi的点正在构建属于它的dfs序列</li>
<li>我们可以确定的是一次dfs会构建出一层的节点的dfs序列</li>
<li>首先会找出子节点（BFS序列中相应的点和根节点dfs序列中相应的点相等），然后再去找该子节点的dfs序列，直到根节点的dfs序列构建为根节点的子节点的dfs序列，此时根节点的子节点均已记录完毕，而树的每个节点的祖先节点（不一定是父节点）也已经记录完毕。</li>
<li>还有一种情况，代代单传（这样的话BFS序列中相应的点和根节点dfs序列中相应的点相等），但并不都是子节点，这样的话好像程序运行所表达的意思就是不正确的，所以这个树应该当作二叉树处理</li>
<li>之后的话意味着这一层的节点的dfs序列已经构建完毕，再去dfs下一层的</li>
</ul>
<h3 id="12-A-Dicey-Problem"><a href="#12-A-Dicey-Problem" class="headerlink" title="12.A Dicey Problem"></a>12.A Dicey Problem</h3><p>题目链接:<a target="_blank" rel="noopener" href="https://vjudge.net/problem/UVA-810">A Dicey Problem - UVA 810 - Virtual Judge (vjudge.net)</a></p>
<p>解析:</p>
<ol>
<li></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">DIR</span>&#123;</span><br><span class="line">	UP = <span class="number">0</span>,LEFT = <span class="number">1</span>,DOWN = <span class="number">2</span>,RIGHT = <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXR = <span class="number">12</span>;</span><br><span class="line"><span class="type">int</span> R,C,M[MAXR][MAXR],dr[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,dc[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">//用于提高内存分配和释放的效率，尤其是在需要频繁创建和销毁对象的情况下</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MemPool</span>&#123;</span><br><span class="line">	vector&lt;T*&gt;buf;</span><br><span class="line">	<span class="function">T* <span class="title">creatNew</span><span class="params">()</span></span>&#123;</span><br><span class="line">		buf.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">T</span>());</span><br><span class="line">		<span class="keyword">return</span> buf.<span class="built_in">back</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">dispose</span><span class="params">()</span></span>&#123;</span><br><span class="line">		_for(i,<span class="number">0</span>,buf.<span class="built_in">size</span>())<span class="keyword">delete</span> buf[i];</span><br><span class="line">		buf.<span class="built_in">clear</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> DL[<span class="number">6</span>][<span class="number">6</span>] = &#123;</span><br><span class="line">	&#123;<span class="number">-1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">-1</span>&#125;,   <span class="comment">//1</span></span><br><span class="line">	&#123;<span class="number">4</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">-1</span>,<span class="number">3</span>&#125;,   <span class="comment">//2</span></span><br><span class="line">	&#123;<span class="number">2</span>,<span class="number">6</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">5</span>&#125;,   <span class="comment">//3</span></span><br><span class="line">	&#123;<span class="number">5</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">6</span>,<span class="number">2</span>&#125;,   <span class="comment">//4</span></span><br><span class="line">	&#123;<span class="number">3</span>,<span class="number">-1</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">4</span>&#125;,   <span class="comment">//5</span></span><br><span class="line">	&#123;<span class="number">-1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">-1</span>&#125;    <span class="comment">//6</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Stat</span>&#123;</span><br><span class="line">	<span class="type">int</span> r,c,face,top,back,bottom,left,right;</span><br><span class="line">	Stat* prev;</span><br><span class="line">	<span class="built_in">Stat</span>():<span class="built_in">prev</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">canMove</span><span class="params">(<span class="type">int</span> dir)</span></span>;</span><br><span class="line">	<span class="function">Stat* <span class="title">move</span><span class="params">(<span class="type">int</span> dir)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> f,<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;face = f;</span><br><span class="line">		<span class="keyword">this</span>-&gt;top = t;</span><br><span class="line">		back = <span class="number">7</span> - face;</span><br><span class="line">		bottom = <span class="number">7</span> - top;</span><br><span class="line">		left = DL[face<span class="number">-1</span>][top<span class="number">-1</span>];</span><br><span class="line">		right = <span class="number">7</span> - left;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">hash</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1000</span>*(r<span class="number">-1</span>)+<span class="number">100</span>*(c<span class="number">-1</span>) + <span class="number">10</span> * face + top;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Stat* PStat;</span><br><span class="line">MemPool&lt;Stat&gt; pool;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PStatCmp</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> PStat&amp; a,<span class="type">const</span> PStat&amp; b)</span><span class="type">const</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a-&gt;<span class="built_in">hash</span>() &lt; b-&gt;<span class="built_in">hash</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Stat::canMove</span><span class="params">(<span class="type">int</span> dir)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> nr = r + dr[dir],nc = c + dc[dir];</span><br><span class="line">	<span class="keyword">if</span>(nr &lt; <span class="number">1</span> || nr &gt; R || nc &lt; <span class="number">1</span> || nc &gt; C)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="type">int</span> m = M[nr][nc];</span><br><span class="line">	<span class="keyword">if</span>(m == <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> m == <span class="number">-1</span> || m == top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">PStat <span class="title">Stat::move</span><span class="params">(<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">	PStat ps = pool.<span class="built_in">creatNew</span>();</span><br><span class="line">	ps-&gt;prev = <span class="keyword">this</span>;</span><br><span class="line">	ps-&gt;r = r + dr[d];</span><br><span class="line">	ps-&gt;c = c + dc[d];</span><br><span class="line">	<span class="keyword">switch</span>(d)&#123;</span><br><span class="line">		<span class="keyword">case</span> UP:</span><br><span class="line">			ps-&gt;<span class="built_in">init</span>(bottom,face);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> LEFT:</span><br><span class="line">			ps-&gt;<span class="built_in">init</span>(face,right);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> DOWN:</span><br><span class="line">			ps-&gt;<span class="built_in">init</span>(top,back);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> RIGHT:</span><br><span class="line">			ps-&gt;<span class="built_in">init</span>(face,left);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ps;</span><br><span class="line">&#125;</span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; is,Stat&amp; s)&#123;</span><br><span class="line">	is&gt;&gt;s.r&gt;&gt;s.c&gt;&gt;s.top&gt;&gt;s.face;</span><br><span class="line">	s.<span class="built_in">init</span>(s.face,s.top);</span><br><span class="line">	<span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>MemPool的目的就是提高内存分配和释放的效率，尤其是在需要频繁创建和销毁对象的情况下，在此题中被用到的时候Stat移动的时候，确实是要建立大量的对象</p>
</li>
<li><p>DL数组不知道其中的数字是怎么来的，可以知道的是如果知道top和face，结合这个数组就可以得到left上的数字了</p>
</li>
<li><p>Stat内的init根据top和face从而算出6个面上的数字（对面之和为7）</p>
<ul>
<li>hash函数则用来set内的排序</li>
<li>canMove函数主要用来判断下一个点的位置是否越界以及是否可以去到这个地方，问题是为什么要||m &#x3D;&#x3D; top呢？其实是没错的，书中说错了。 However, you can only move onto a square that contains the same number as the number displayed on the top of the die before the move.</li>
<li>move函数则是使用内存此建立了一个新的对象，然后初始化它的六个面，它的位置，最后返对象的指针，一般来说为了节省空间是要返回指针的，但在函数这里是不能返回参数的</li>
</ul>
</li>
<li><p>还有一个cin&gt;&gt;的重载，更加方便</p>
</li>
</ul>
<ol start="2">
<li></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// streambuf *cinbuf = cin.rdbuf();</span></span><br><span class="line">	<span class="comment">// cin.rdbuf(input.rdbuf());</span></span><br><span class="line">	string name;</span><br><span class="line">	deque&lt;PStat&gt; outQ;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;name &amp;&amp; name != <span class="string">&quot;END&quot;</span>)&#123;</span><br><span class="line">		Stat s;</span><br><span class="line">		cin&gt;&gt;R&gt;&gt;C&gt;&gt;s;</span><br><span class="line">		_for(r,<span class="number">1</span>,R+<span class="number">1</span>)</span><br><span class="line">			_for(c,<span class="number">1</span>,C+<span class="number">1</span>)</span><br><span class="line">				cin&gt;&gt;M[r][c];</span><br><span class="line">		output&lt;&lt;name&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		Stat* ans = <span class="literal">NULL</span>;</span><br><span class="line">		_for(i,<span class="number">0</span>,<span class="number">4</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(s.<span class="built_in">canMove</span>(i))&#123;</span><br><span class="line">				ans = <span class="built_in">solve</span>(s,s.<span class="built_in">move</span>(i));</span><br><span class="line">				<span class="keyword">if</span>(ans)<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(ans)&#123;</span><br><span class="line">			outQ.<span class="built_in">clear</span>();</span><br><span class="line">			<span class="keyword">while</span>(ans)&#123;</span><br><span class="line">				outQ.<span class="built_in">push_front</span>(ans);</span><br><span class="line">				ans = ans-&gt;prev;</span><br><span class="line">			&#125;</span><br><span class="line">			_for(i,<span class="number">0</span>,outQ.<span class="built_in">size</span>())&#123;</span><br><span class="line">				<span class="keyword">if</span>(i)&#123;</span><br><span class="line">					output&lt;&lt;<span class="string">&quot;,&quot;</span>;</span><br><span class="line">					<span class="keyword">if</span>(i%<span class="number">9</span> == <span class="number">0</span>)output&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(i % <span class="number">9</span> == <span class="number">0</span>)output&lt;&lt;<span class="string">&quot;  &quot;</span>;</span><br><span class="line">				output&lt;&lt;<span class="string">&quot;(&quot;</span>&lt;&lt;outQ[i]-&gt;r&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;outQ[i]-&gt;c&lt;&lt;<span class="string">&quot;)&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			output&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span></span><br><span class="line">			output&lt;&lt;<span class="string">&quot;  No Solution Possible&quot;</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		pool.<span class="built_in">dispose</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>程序没有把起点压入队列，为什么最后答案中有起点，因为起点在move时就已经和下一个点建立了链接，从而输出答案时就能打印出来</li>
<li>关于打印，除的第一个前不用打印逗号，其他都要打印；而且每行的第一个前要空两格；每9个就要换行；而且是先打印前面的逗号再换行</li>
<li>最后不要忘记内存池的释放（自己写的内存池相对于系统往往是一次分配大块连续的内存）</li>
</ul>
<ol start="3">
<li></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stat* <span class="title">solve</span><span class="params">(<span class="type">const</span> Stat&amp; destS,PStat ps)</span></span>&#123;</span><br><span class="line">	queue&lt;PStat&gt; q;</span><br><span class="line">	set&lt;PStat,PStatCmp&gt; vis;</span><br><span class="line">	q.<span class="built_in">push</span>(ps);vis.<span class="built_in">insert</span>(ps);</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		PStat p = q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;r == destS.r &amp;&amp; p-&gt;c == destS.c)<span class="keyword">return</span> p;</span><br><span class="line">		_for(d,<span class="number">0</span>,<span class="number">4</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!p-&gt;<span class="built_in">canMove</span>(d))<span class="keyword">continue</span>;</span><br><span class="line">			PStat np = p-&gt;<span class="built_in">move</span>(d);</span><br><span class="line">			<span class="keyword">if</span>(vis.<span class="built_in">count</span>(np))<span class="keyword">continue</span>;</span><br><span class="line">			vis.<span class="built_in">insert</span>(np);</span><br><span class="line">			q.<span class="built_in">push</span>(np);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用bfs，先判断队列中的地点是否是目的地（所以这也是起点没有进队列的原因，因为目的地和起点相同），然后再判断每个方向是否能去，是否去过（以相同的状态），如果没去过就压进队列和set。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/10/08/23-10-8/" data-id="clno8qmwf000418jdckog9fee" data-title="23.10.8" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2023/10/10/23-10-10/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2023/10/05/23-10-5/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">23.10.5</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BF%83%E6%83%85/">心情</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E6%9E%90/" rel="tag">分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A8%A1%E6%8B%9F/" rel="tag">模拟</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/" rel="tag">算法练习</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E5%88%86%E6%9E%90/" style="font-size: 20px;">分析</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">数据结构</a> <a href="/tags/%E6%A8%A1%E6%8B%9F/" style="font-size: 20px;">模拟</a> <a href="/tags/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/" style="font-size: 10px;">算法练习</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">September 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/10/10/23-10-10/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/10/08/23-10-8/">23.10.8</a>
          </li>
        
          <li>
            <a href="/2023/10/05/23-10-5/">23.10.5</a>
          </li>
        
          <li>
            <a href="/2023/10/03/23-10-3/">23.10.3-10.4</a>
          </li>
        
          <li>
            <a href="/2023/10/02/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE23-10-2/">算法题目23.10.2</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>