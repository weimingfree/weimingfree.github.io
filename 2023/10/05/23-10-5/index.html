<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>23.10.5 | experience sharing</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="继续模拟">
<meta property="og:type" content="article">
<meta property="og:title" content="23.10.5">
<meta property="og:url" content="http://example.com/2023/10/05/23-10-5/index.html">
<meta property="og:site_name" content="experience sharing">
<meta property="og:description" content="继续模拟">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-10-05T04:32:04.000Z">
<meta property="article:modified_time" content="2023-10-08T10:38:40.899Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="模拟">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="experience sharing" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">experience sharing</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">xu jian</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-23-10-5" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/10/05/23-10-5/" class="article-date">
  <time class="dt-published" datetime="2023-10-05T04:32:04.000Z" itemprop="datePublished">2023-10-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      23.10.5
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="继续模拟"><a href="#继续模拟" class="headerlink" title="继续模拟"></a>继续模拟</h1><span id="more"></span>

<h3 id="1-Queue-and-A"><a href="#1-Queue-and-A" class="headerlink" title="1.Queue and A"></a>1.Queue and A</h3><p>题目链接：<a target="_blank" rel="noopener" href="https://vjudge.net/problem/UVA-822">Queue and A - UVA 822 - Virtual Judge (vjudge.net)</a></p>
<p>解析：</p>
<p>1.首先应该熟悉这道题用到的数据结构</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Event</span>&#123;</span><br><span class="line">	<span class="type">int</span> time,id;</span><br><span class="line">	<span class="type">bool</span> isRorC;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Event&amp; e)<span class="type">const</span>&#123;<span class="keyword">return</span> time &gt; e.time;&#125;<span class="comment">//事件的优先级更加靠后</span></span><br><span class="line">	<span class="built_in">Event</span>(<span class="type">int</span> t,<span class="type">int</span> i,<span class="type">bool</span> isr = <span class="literal">true</span>):<span class="built_in">time</span>(t),<span class="built_in">id</span>(i),<span class="built_in">isRorC</span>(isr)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;Event&gt; em;</span><br></pre></td></tr></table></figure>

<p> 这就是事件类，这个事件可以是要来到的请求，也可以是空闲的工作人员，它们根据到来的时间早完进行排序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ReqInfo</span>&#123;<span class="type">int</span> tid,num,t0,t,dt;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StaffInfo</span>&#123;</span><br><span class="line">	<span class="type">int</span> pid,k,tids[maxn],idx,last;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> StaffInfo&amp; s)<span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> last &lt; s.last || (last == s.last &amp;&amp; pid &lt; s.pid);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">ReqInfo reqs[maxn];</span><br><span class="line">StaffInfo staffs[maxm];</span><br></pre></td></tr></table></figure>

<p>这些都是请求和员工的基本信息，往后看你会发现请求的tid以及员工的pid基本是用不到的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">multiset&lt;<span class="type">int</span>&gt; rQs;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; freeStaffs;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StaffComp</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span><span class="type">const</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> staffs[l] &lt;staffs[r];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">set&lt;<span class="type">int</span>,StaffComp&gt; rt[maxn];</span><br></pre></td></tr></table></figure>

<p>这三个set用来存储当前需要处理的请求，当前空闲的员工，以及目前能够处理该请求的员工。</p>
<p>至于当前需要处理的请求为什么要用mutilset，这是因为需要处理的请求可能因为当时没有被处理而被堆积，所以可能出现ix相同的请求。</p>
<p>可以从这里学到什么？</p>
<ul>
<li>priority_queue比较大小只用在基本元素中重载&lt;即可，因为它默认是优先级高的放在前面</li>
<li>而set你要规定一个默认的排列顺序，怎么规定呢？写一个类，重载()运算符，而对于此题来说，还要在基本元素中重载&lt;运算符，因为要在重载()运算符函数被用到</li>
<li>那么关于员工优先级，为什么不用priority_queue呢？</li>
</ul>
<p>2.关于建立信息集合的过程细节</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(cin&gt;&gt;n &amp;&amp; n)&#123;</span><br><span class="line">		freeStaffs.<span class="built_in">clear</span>(),tids.<span class="built_in">clear</span>(),rQs.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">			<span class="keyword">auto</span>&amp; r = reqs[i];</span><br><span class="line">			cin&gt;&gt;r.tid&gt;&gt;r.num&gt;&gt;r.t0&gt;&gt;r.t&gt;&gt;r.dt;</span><br><span class="line">			tids[r.tid] = i;</span><br><span class="line">			r.tid = i;</span><br><span class="line">			<span class="comment">//优先级高（发生早的事件）放在前面</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; r.num;j++)em.<span class="built_in">push</span>(<span class="built_in">Event</span>(r.t0+r.dt*j,i));</span><br><span class="line">		&#125;</span><br><span class="line">		cin&gt;&gt;m;</span><br><span class="line">		_for(i,<span class="number">0</span>,m)&#123;</span><br><span class="line">			<span class="keyword">auto</span>&amp; s = staffs[i];</span><br><span class="line">			cin&gt;&gt;s.pid&gt;&gt;s.k;</span><br><span class="line">			_for(j,<span class="number">0</span>,s.k)&#123;</span><br><span class="line">				cin&gt;&gt;s.tids[j];</span><br><span class="line">				s.tids[j] = tids[s.tids[j]];</span><br><span class="line">			&#125;</span><br><span class="line">			s.last = <span class="number">0</span>;</span><br><span class="line">			s.idx = i;</span><br><span class="line">			em.<span class="built_in">push</span>(<span class="built_in">Event</span>(<span class="number">0</span>,s.idx,<span class="literal">false</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(!em.<span class="built_in">empty</span>())<span class="built_in">solve</span>();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>细节：请求的原来的tid是没有用的，通过映射会把它映射为一个比较小的tid；而员工的pid不能说没有作用，仅仅在员工优先级比较时使用到，其他时候使用idx起到辨别作用，这样做的好处就是它们的id和保存它们信息的数组的下标是相同的，而且Event中的id也都是这种简化后的id</li>
<li>发现在开头空闲的员工，当前需要处理的请求都被清空<ul>
<li>那么事件队列em怎么不请空，因为在处理完上一个场景之后它必然是空的</li>
<li>此时适合的员工为什么不清空，因为这个量更像是一个时刻量，在每分配一个任务后适合的员工都是不相同的，需要每分配一次就重写一次，而空闲员工，当前需求更像是过程量，会随着时间的推移减少或者增加</li>
</ul>
</li>
</ul>
<p>3.模拟请求处理过程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> time = em.<span class="built_in">top</span>().time;</span><br><span class="line">	<span class="keyword">while</span>(!em.<span class="built_in">empty</span>() &amp;&amp; time == em.<span class="built_in">top</span>().time)&#123;</span><br><span class="line">		<span class="type">const</span> Event&amp; e = em.<span class="built_in">top</span>();</span><br><span class="line">		<span class="keyword">if</span>(e.isRorC)rQs.<span class="built_in">insert</span>(e.id);</span><br><span class="line">		<span class="keyword">else</span> freeStaffs.<span class="built_in">insert</span>(e.id);</span><br><span class="line">		em.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!rQs.<span class="built_in">empty</span>() &amp;&amp; !freeStaffs.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		_for(i,<span class="number">0</span>,n)rt[i].<span class="built_in">clear</span>();</span><br><span class="line">		<span class="type">bool</span> canAssign = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : freeStaffs)&#123;</span><br><span class="line">			<span class="keyword">auto</span>&amp; si = staffs[i];</span><br><span class="line">			_for(j,<span class="number">0</span>,si.k)&#123;</span><br><span class="line">				<span class="type">int</span> tid = si.tids[j];</span><br><span class="line">				<span class="keyword">if</span>(!rQs.<span class="built_in">count</span>(tid))<span class="keyword">continue</span>;</span><br><span class="line">				canAssign = <span class="literal">true</span>;</span><br><span class="line">				rt[tid].<span class="built_in">insert</span>(si.idx);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!canAssign)<span class="keyword">break</span>;</span><br><span class="line">		_for(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">			<span class="keyword">auto</span>&amp; ss = rt[i];</span><br><span class="line">			<span class="keyword">while</span>(rQs.<span class="built_in">count</span>(i) &amp;&amp; !ss.<span class="built_in">empty</span>())&#123;</span><br><span class="line">				rQs.<span class="built_in">erase</span>(rQs.<span class="built_in">find</span>(i));</span><br><span class="line">				<span class="type">int</span> si = *(ss.<span class="built_in">begin</span>());</span><br><span class="line">				<span class="keyword">auto</span>&amp; s = staffs[si];</span><br><span class="line">				s.last = time;</span><br><span class="line">				em.<span class="built_in">push</span>(<span class="built_in">Event</span>(time+reqs[i].t,s.idx,<span class="literal">false</span>));</span><br><span class="line">				freeStaffs.<span class="built_in">erase</span>(s.idx);</span><br><span class="line">				ss.<span class="built_in">erase</span>(si);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(em.<span class="built_in">empty</span>())</span><br><span class="line">		output&lt;&lt;<span class="string">&quot;Scenario &quot;</span>&lt;&lt;kase++&lt;&lt;<span class="string">&quot;: All requests are serviced within &quot;</span>&lt;&lt;time&lt;&lt;<span class="string">&quot; minutes.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>首先将此时此刻空闲的员工和发生的请求与之前空闲的员工和未处理的请求一起假如到对应的序列当中</p>
</li>
<li><p>第二个while大循环的期待是每循环一次就处理掉请求队列中的一些请求</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : freeStaffs)&#123;</span><br><span class="line">	<span class="keyword">auto</span>&amp; si = staffs[i];</span><br><span class="line">	_for(j,<span class="number">0</span>,si.k)&#123;</span><br><span class="line">		<span class="type">int</span> tid = si.tids[j];</span><br><span class="line">		<span class="keyword">if</span>(!rQs.<span class="built_in">count</span>(tid))<span class="keyword">continue</span>;</span><br><span class="line">		canAssign = <span class="literal">true</span>;</span><br><span class="line">		rt[tid].<span class="built_in">insert</span>(si.idx);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将所有的员工遍历一遍，这样导致的结果就是可能有的任务它有多个待选之人，也有可能所有的任务都没有人选，都没有人选的话说明此时的大循环是没有用的。</li>
<li>一个员工只能分配一次，这样的员工更加倾向于分配到在他任务列表中靠前的任务，因为员工的可执行任务列表本来就是有优先级的，这样其实也是符合题意的</li>
</ul>
</li>
<li><p>这里用来处理拥有待选员工的请求</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_for(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">	<span class="keyword">auto</span>&amp; ss = rt[i];</span><br><span class="line">	<span class="keyword">while</span>(rQs.<span class="built_in">count</span>(i) &amp;&amp; !ss.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		rQs.<span class="built_in">erase</span>(rQs.<span class="built_in">find</span>(i));</span><br><span class="line">		<span class="type">int</span> si = *(ss.<span class="built_in">begin</span>());</span><br><span class="line">		<span class="keyword">auto</span>&amp; s = staffs[si];</span><br><span class="line">		s.last = time;</span><br><span class="line">		em.<span class="built_in">push</span>(<span class="built_in">Event</span>(time+reqs[i].t,s.idx,<span class="literal">false</span>));</span><br><span class="line">		freeStaffs.<span class="built_in">erase</span>(si);</span><br><span class="line">		ss.<span class="built_in">erase</span>(si);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里将可以处理的请求，以及处理请求的员工从各自的队列中请求，以及维护员工最后一次处理请求的时间和事件的队列</li>
<li>需要注意的是第三行用while是因为ix相同的事件可能不只一件，第四行erase这样处理也是因为这样只会消除一件请求，而不是消除多件相同的请求</li>
<li>当最后一件请求被处理后，还要等员工处理完成后才意味着请求完成。这样的话空闲员工队列最后一定是满的，所以要在开头清空，而任务队列其实是必然空的，所以在main函数那里其实也没有必要去清空</li>
</ul>
</li>
</ul>
<h3 id="2-Exchange"><a href="#2-Exchange" class="headerlink" title="2.Exchange"></a>2.Exchange</h3><p>题目链接：<a target="_blank" rel="noopener" href="https://vjudge.net/problem/UVA-1598">Exchange - UVA 1598 - Virtual Judge (vjudge.net)</a></p>
<p>解析：<br>这种题目光理解题意就会费力，更想不出其中的做法</p>
<p>1.首先看一下所用的数据结构</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,oIX[MAXN],canceled[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Order</span>&#123;</span><br><span class="line">	<span class="type">bool</span> buy;</span><br><span class="line">	<span class="type">int</span> size,price;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Order&gt; orders;</span><br></pre></td></tr></table></figure>

<p> 我一开始有个疑惑，就是oIX数组在程序中使用并不多，能否不去使用；但是事实是不可以，因为cancel指令指的是第n条指令，包括前面的cancel指令，所以要搞一个映射，从实际上第n条指令映射到只有sell和buy指令的序号</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Compare&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">OrderQueue</span>&#123;</span><br><span class="line">	set&lt;<span class="type">int</span>,Compare&gt; eles;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;eles.<span class="built_in">erase</span>(eles.<span class="built_in">find</span>(x));&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span><span class="type">const</span> </span>&#123;<span class="keyword">return</span> eles.<span class="built_in">empty</span>();&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span><span class="type">const</span> </span>&#123;<span class="keyword">return</span> *eles.<span class="built_in">begin</span>();&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> ans = *eles.<span class="built_in">begin</span>();</span><br><span class="line">		eles.<span class="built_in">erase</span>(eles.<span class="built_in">begin</span>());</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;eles.<span class="built_in">insert</span>(i);&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span><span class="type">const</span></span>&#123;<span class="keyword">return</span> eles.<span class="built_in">size</span>();&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;eles.<span class="built_in">clear</span>();&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">topPrice</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> orders[<span class="built_in">top</span>()].price;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">topSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> tp = <span class="built_in">topPrice</span>(),ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> it = eles.<span class="built_in">begin</span>();it != eles.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">			<span class="type">const</span> Order&amp; o = orders[*it];</span><br><span class="line">			<span class="keyword">if</span>(o.price == tp)ans += o.size;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BuyOrderCompare</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">		<span class="type">const</span> Order&amp; oi = orders[i];</span><br><span class="line">		<span class="type">const</span> Order&amp; oj = orders[j];</span><br><span class="line">		<span class="keyword">return</span> oi.price &gt; oj.price || (oi.price == oj.price &amp;&amp; i &lt; j);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SellOrderCompare</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">		<span class="type">const</span> Order&amp; oi = orders[i];</span><br><span class="line">		<span class="type">const</span> Order&amp; oj = orders[j];</span><br><span class="line">		<span class="keyword">return</span> oi.price &lt; oj.price || (oi.price == oj.price &amp;&amp; i &lt; j);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">OrderQueue&lt;BuyOrderCompare&gt;buyQueue;</span><br><span class="line">OrderQueue&lt;SellOrderCompare&gt;sellQueue;</span><br></pre></td></tr></table></figure>

<p>此处的数据结构就难以想到，将sell和buy指令都存到set序列，而这两个序列的不同之处在于它们的排列规则不同，一个是按照价格低的在前面，一个是价格高的在前面，毕竟买东西肯定倾向于价格低的，而卖东西倾向于价格高的，低进高出。</p>
<ol start="2">
<li></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// streambuf *cinbuf = cin.rdbuf();</span></span><br><span class="line">	<span class="comment">// cin.rdbuf(input.rdbuf());</span></span><br><span class="line">	string cmd;</span><br><span class="line">	<span class="type">bool</span> first = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">		<span class="keyword">if</span>(first)first = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">else</span> output&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		<span class="built_in">fill_n</span>(oIX,n,<span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">fill_n</span>(canceled,n,<span class="number">0</span>);</span><br><span class="line">		orders.<span class="built_in">clear</span>();</span><br><span class="line">		buyQueue.<span class="built_in">clear</span>();</span><br><span class="line">		sellQueue.<span class="built_in">clear</span>();</span><br><span class="line">		_for(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">			cin&gt;&gt;cmd;</span><br><span class="line">			<span class="keyword">if</span>(cmd == <span class="string">&quot;CANCEL&quot;</span>)&#123;</span><br><span class="line">				<span class="type">int</span> x;</span><br><span class="line">				cin&gt;&gt;x;</span><br><span class="line">				<span class="built_in">cancel</span>(x<span class="number">-1</span>);</span><br><span class="line">				<span class="built_in">quote</span>();</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			Order o;</span><br><span class="line">			cin&gt;&gt;o.size&gt;&gt;o.price;</span><br><span class="line">			o.buy = (cmd == <span class="string">&quot;BUY&quot;</span>);</span><br><span class="line">			oIX[i] = orders.<span class="built_in">size</span>();</span><br><span class="line">			orders.<span class="built_in">push_back</span>(o);</span><br><span class="line">			<span class="built_in">trade</span>(oIX[i]);</span><br><span class="line">			<span class="built_in">quote</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般而言主函数就是所作的工作就是符合打印的要求，数组，集合初始化，以及把握程序的主脉络</p>
<p>关于为什么在交易之后要标价呢？在交易之后原来的sell 和buy序列都会发生改变，所以要重新标价，展示给后来交易的人</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cancel</span><span class="params">(<span class="type">int</span> ci)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i = oIX[ci];</span><br><span class="line">	<span class="keyword">if</span>(canceled[i])<span class="keyword">return</span>;</span><br><span class="line">	<span class="type">const</span> Order&amp; o = orders[i];</span><br><span class="line">	<span class="keyword">if</span>(o.buy)buyQueue.<span class="built_in">erase</span>(i);</span><br><span class="line">	<span class="keyword">else</span> sellQueue.<span class="built_in">erase</span>(i);</span><br><span class="line">	canceled[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quote</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> bidSize = <span class="number">0</span>,bidPrice = <span class="number">0</span>,askSize = <span class="number">0</span>,askPrice = <span class="number">99999</span>;</span><br><span class="line">	<span class="keyword">if</span>(!buyQueue.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		bidSize = buyQueue.<span class="built_in">topSize</span>();</span><br><span class="line">		bidPrice = buyQueue.<span class="built_in">topPrice</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!sellQueue.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		askSize = sellQueue.<span class="built_in">topSize</span>();</span><br><span class="line">		askPrice = sellQueue.<span class="built_in">topPrice</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	output&lt;&lt;<span class="string">&quot;QUOTE &quot;</span>&lt;&lt;bidSize&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;bidPrice&lt;&lt;<span class="string">&quot; - &quot;</span>&lt;&lt;askSize&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;askPrice&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>取消某条order，是要在对应的队列中将其抹除，但是不影响该order之前的交易</li>
<li>而报价的内容都会随着当前的情况有所变化。</li>
</ul>
<p>3.交易过程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">trade</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">	Order&amp; o = orders[i];</span><br><span class="line">	<span class="keyword">if</span>(o.buy)&#123;</span><br><span class="line">		<span class="keyword">if</span>(sellQueue.<span class="built_in">empty</span>() || o.price &lt; sellQueue.<span class="built_in">topPrice</span>())&#123;</span><br><span class="line">			buyQueue.<span class="built_in">push</span>(i);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> askPrice;</span><br><span class="line">		<span class="keyword">while</span>(!sellQueue.<span class="built_in">empty</span>() &amp;&amp; o.size &gt; <span class="number">0</span> &amp;&amp; o.price &gt;= (askPrice = sellQueue.<span class="built_in">topPrice</span>()))&#123;</span><br><span class="line">			<span class="type">int</span> toi = sellQueue.<span class="built_in">top</span>();</span><br><span class="line">			Order&amp; to = orders[toi];</span><br><span class="line">			<span class="type">int</span> treadSize = <span class="built_in">min</span>(o.size,to.size);</span><br><span class="line">			output&lt;&lt;<span class="string">&quot;TRADE &quot;</span>&lt;&lt;treadSize&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;askPrice&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">			to.size -= treadSize;</span><br><span class="line">			o.size -= treadSize;</span><br><span class="line">			sellQueue.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">if</span>(to.size == <span class="number">0</span>)canceled[toi] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> sellQueue.<span class="built_in">push</span>(toi);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(o.size &gt; <span class="number">0</span>)buyQueue.<span class="built_in">push</span>(i);</span><br><span class="line">		<span class="keyword">else</span> canceled[i] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(buyQueue.<span class="built_in">empty</span>() || o.price &gt; buyQueue.<span class="built_in">topPrice</span>())&#123;</span><br><span class="line">		sellQueue.<span class="built_in">push</span>(i);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> bidPrice;</span><br><span class="line">	<span class="keyword">while</span>(!buyQueue.<span class="built_in">empty</span>() &amp;&amp; o.size &gt; <span class="number">0</span> &amp;&amp; o.price &lt;= (bidPrice = buyQueue.<span class="built_in">topPrice</span>()))&#123;</span><br><span class="line">			<span class="type">int</span> toi = buyQueue.<span class="built_in">top</span>();</span><br><span class="line">			Order&amp; to = orders[toi];</span><br><span class="line">			<span class="type">int</span> treadSize = <span class="built_in">min</span>(o.size,to.size);</span><br><span class="line">			output&lt;&lt;<span class="string">&quot;TRADE &quot;</span>&lt;&lt;treadSize&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;bidPrice&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">			to.size -= treadSize;</span><br><span class="line">			o.size -= treadSize;</span><br><span class="line">			buyQueue.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">if</span>(to.size == <span class="number">0</span>)canceled[toi] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> buyQueue.<span class="built_in">push</span>(toi);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(o.size &gt; <span class="number">0</span>)sellQueue.<span class="built_in">push</span>(i);</span><br><span class="line">	<span class="keyword">else</span> canceled[i] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sell和buy过程是比较相似的，以buy为例。</p>
<ul>
<li>如果当前没有人sell或者说你buy的价格小于sell价格的最低价，你是无法购买的，所以只能将这个订单暂存。</li>
<li>如果说满足上面这些条件，那么你的期望就是将这个buy订单消磨掉，在这个过程中你可能会消磨掉sell订单，buy订单也被消磨掉；也有可能你的buy订单最后也没有被消磨完，只能将这个剩余的buy订单暂存起来；注意被消磨完毕的订单要从队列中pop出来以及在取消订单中标注</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(buyQueue.<span class="built_in">empty</span>() || o.price &gt; buyQueue.<span class="built_in">topPrice</span>())&#123;</span><br><span class="line">           sellQueue.<span class="built_in">push</span>(i);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> bidprice;</span><br><span class="line">       <span class="keyword">while</span>(!buyQueue.<span class="built_in">empty</span>() &amp;&amp; o.size &gt; <span class="number">0</span> &amp;&amp; o.price &lt;= (bidprice = buyQueue.<span class="built_in">topPrice</span>()))&#123;</span><br><span class="line">           Order&amp; to = orders[buyQueue.<span class="built_in">top</span>()];</span><br><span class="line">           <span class="type">int</span> treadS = <span class="built_in">min</span>(o.size,to.size);</span><br><span class="line">           to.size -= treadS;</span><br><span class="line">           o.size -= treadS;</span><br><span class="line">           output&lt;&lt;<span class="string">&quot;TRADE &quot;</span>&lt;&lt;treadS&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;bidprice&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">           <span class="keyword">if</span>(to.size == <span class="number">0</span>)&#123;</span><br><span class="line">               canceled[buyQueue.<span class="built_in">top</span>()] = <span class="number">1</span>;</span><br><span class="line">               buyQueue.<span class="built_in">pop</span>();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(o.size &gt; <span class="number">0</span>)sellQueue.<span class="built_in">push</span>(i);</span><br><span class="line">       <span class="keyword">else</span> canceled[i] = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span>; </span><br></pre></td></tr></table></figure>

<p>以sell为例，修改一点，即当一个buy order最终的size仍然存在时，是不需要出队列的</p>
<h3 id="3-Revenge-of-Fibonacci"><a href="#3-Revenge-of-Fibonacci" class="headerlink" title="3.Revenge of Fibonacci"></a>3.Revenge of Fibonacci</h3><p>题目链接:<a target="_blank" rel="noopener" href="https://vjudge.net/problem/UVA-12333">Revenge of Fibonacci - UVA 12333 - Virtual Judge (vjudge.net)</a></p>
<p>解析:</p>
<p>1.数据结构前缀树</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> MaxNode,<span class="type">int</span> Sigma_Size&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Trie</span>&#123;</span><br><span class="line">	<span class="type">int</span> ch[MaxNode][Sigma_Size],sz,val[MaxNode];</span><br><span class="line">	<span class="built_in">Trie</span>()&#123;</span><br><span class="line">		sz = <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">memset</span>(ch[<span class="number">0</span>],<span class="number">0</span>,<span class="built_in">sizeof</span>(ch[<span class="number">0</span>]));</span><br><span class="line">		<span class="built_in">memset</span>(val,<span class="number">0</span>,<span class="built_in">sizeof</span>(val));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">idx</span><span class="params">(<span class="type">char</span> c)</span><span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> string&amp; s,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> u = <span class="number">0</span>,n = s.<span class="built_in">size</span>();</span><br><span class="line">		_for(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">			<span class="type">int</span> c = <span class="built_in">idx</span>(s[i]);</span><br><span class="line">			<span class="keyword">if</span>(!ch[u][c])&#123;</span><br><span class="line">				<span class="built_in">memset</span>(ch[sz],<span class="number">0</span>,<span class="built_in">sizeof</span>(ch[sz]));</span><br><span class="line">				val[sz] = v;</span><br><span class="line">				ch[u][c] = sz++;</span><br><span class="line">			&#125;</span><br><span class="line">			u = ch[u][c];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!val[u])val[u] = v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">(<span class="type">const</span> string&amp; s)</span><span class="type">const</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> v = <span class="number">-1</span>,u = <span class="number">0</span>,n = s.<span class="built_in">size</span>();</span><br><span class="line">		_for(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">			<span class="type">int</span> c = <span class="built_in">idx</span>(s[i]);</span><br><span class="line">			<span class="keyword">if</span>(!ch[u][c])<span class="keyword">return</span> v;</span><br><span class="line">			u = ch[u][c];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(val[u])v = val[u];</span><br><span class="line">		<span class="keyword">return</span> v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Trie&lt;<span class="number">3817223</span>,<span class="number">10</span>&gt;pfxes;</span><br></pre></td></tr></table></figure>

<ul>
<li>前缀树是怎么保存数据的？<ul>
<li>保存值的数组，当前节点的个数，记录位置的数组</li>
</ul>
</li>
</ul>
<p>2.一万进制的大整数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> BASE = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> maxn&gt;</span><br><span class="line"><span class="comment">//一万进制的大整数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bign</span>&#123;</span><br><span class="line">	 <span class="type">int</span> len,s[maxn];</span><br><span class="line">	 <span class="built_in">bign</span>()&#123;</span><br><span class="line">		<span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="built_in">sizeof</span>(s));</span><br><span class="line">		len = <span class="number">1</span>;</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="built_in">bign</span>(<span class="type">int</span> num)&#123;</span><br><span class="line">		*<span class="keyword">this</span> = num;</span><br><span class="line">	 &#125;</span><br><span class="line">	 bign&amp; <span class="keyword">operator</span>=(<span class="type">int</span> num)&#123;</span><br><span class="line">		<span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">			len = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		len = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">			s[len++] = num % BASE;</span><br><span class="line">			num /= BASE;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	 &#125;</span><br><span class="line">	 bign&amp; <span class="keyword">operator</span>=(<span class="type">const</span> bign&amp; b)&#123;</span><br><span class="line">		len = b.len;</span><br><span class="line">		<span class="built_in">copy</span>(b.s,b.s+b.len,s);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXF = <span class="number">100000</span>,MAXLEN = <span class="number">5300</span>;</span><br><span class="line"><span class="keyword">typedef</span> bign&lt;MAXLEN&gt; BigFn;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">const</span> BigFn&amp; a,<span class="type">const</span> BigFn&amp; b,BigFn&amp; c)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> *cs = c.s,l = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> mLen = <span class="built_in">max</span>(a.len,b.len);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>,g = <span class="number">0</span>;g || i &lt; mLen;i++)&#123;</span><br><span class="line">		<span class="type">int</span> x = g;</span><br><span class="line">		<span class="keyword">if</span>(i &lt; a.len) x += a.s[i];</span><br><span class="line">		<span class="keyword">if</span>(i &lt; b.len) x += b.s[i];</span><br><span class="line">		cs[l++] = x % BASE;</span><br><span class="line">		g = x / BASE;</span><br><span class="line">	&#125;</span><br><span class="line">	c.len = l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>其实第二个构造函数中的神奇等式是基于等号已经重载的情况</li>
<li>两个大整数相加，比较好地处理了进位的问题</li>
</ul>
<p>3.得到一个大整数多对应的字符串</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">getPfx</span><span class="params">(<span class="type">const</span> BigFn&amp; f,<span class="type">int</span> len = <span class="number">41</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ol = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">8</span>];</span><br><span class="line">	stringstream ss;</span><br><span class="line">	<span class="type">bool</span> first = <span class="literal">true</span>;</span><br><span class="line">	_for(i,<span class="number">0</span>,f.len)&#123;</span><br><span class="line">		<span class="keyword">if</span>(first)&#123;</span><br><span class="line">			first = <span class="literal">false</span>;</span><br><span class="line">			<span class="built_in">sprintf</span>(buf,<span class="string">&quot;%d&quot;</span>,f.s[f.len-i<span class="number">-1</span>]);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">sprintf</span>(buf,<span class="string">&quot;%04d&quot;</span>,f.s[f.len-i<span class="number">-1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		ss&lt;&lt;buf;</span><br><span class="line">		ol += <span class="built_in">strlen</span>(buf);</span><br><span class="line">		<span class="keyword">if</span>(ol &gt;= len)<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意，这里有个前提是len &#x3D; 41,意味着前缀最多取40位，你不必得到这个大整数的所有位数所代表的前缀</li>
<li>sprintf函数可以将各种类型按照指定的格式写入指定char数组中</li>
<li>将buf[8]改成buf[4]</li>
<li>规定格式非常简洁</li>
</ul>
<ol start="4">
<li></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">BigFn f0 = <span class="number">1</span>,f1 = <span class="number">1</span>,f;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// streambuf *cinbuf = cin.rdbuf();</span></span><br><span class="line">	<span class="comment">// cin.rdbuf(input.rdbuf());</span></span><br><span class="line">	_for(i,<span class="number">2</span>,MAXF)&#123;</span><br><span class="line">		<span class="built_in">Add</span>(f0,f1,f);</span><br><span class="line">		string pfx = <span class="built_in">getPfx</span>(f);</span><br><span class="line">		pfxes.<span class="built_in">insert</span>(pfx,i);</span><br><span class="line">		f0 = f1;</span><br><span class="line">		f1 = f;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	cin&gt;&gt;T;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">1</span>;t &lt;= T;t++)&#123;</span><br><span class="line">		cin&gt;&gt;buf;</span><br><span class="line">		<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="function">string <span class="title">p</span><span class="params">(buf)</span></span>;</span><br><span class="line">		<span class="keyword">if</span>(p != <span class="string">&quot;1&quot;</span>)ans = pfxes.<span class="built_in">getValue</span>(p);</span><br><span class="line">		output&lt;&lt;<span class="string">&quot;Case #&quot;</span>&lt;&lt;t&lt;&lt;<span class="string">&quot;: &quot;</span>&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>主函数也并不是特别简洁，比如buf本就可以是string类型的</li>
</ul>
<h3 id="4-Use-of-Hospital-Facilities"><a href="#4-Use-of-Hospital-Facilities" class="headerlink" title="4.Use of Hospital Facilities"></a>4.Use of Hospital Facilities</h3><p>题目链接:<a target="_blank" rel="noopener" href="https://vjudge.net/problem/UVA-212">Use of Hospital Facilities - UVA 212 - Virtual Judge (vjudge.net)</a></p>
<p>解析：<br>1.该题所用的数据结构</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">eventType</span>&#123;</span><br><span class="line">	opFree = <span class="number">0</span>,</span><br><span class="line">	opPre = <span class="number">1</span>,</span><br><span class="line">	reFree = <span class="number">2</span>,</span><br><span class="line">	rePre = <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Room</span>&#123;</span><br><span class="line">	<span class="type">int</span> pat,minutes;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">		pat = <span class="number">-1</span>;</span><br><span class="line">		minutes = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Event</span>&#123;</span><br><span class="line">	<span class="type">int</span> time,id,type;</span><br><span class="line">	<span class="built_in">Event</span>(<span class="type">int</span> t,<span class="type">int</span> id,<span class="type">int</span> type):<span class="built_in">time</span>(t),<span class="built_in">id</span>(id),<span class="built_in">type</span>(type)&#123;&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Event&amp; e)<span class="type">const</span> &#123;<span class="keyword">return</span> time &gt; e.time;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;Event&gt; em;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Patient</span>&#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> sT,rT,opID,opBT,opET,</span><br><span class="line">	reId,reBT,reET;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> nOP,nRE,T0,tTrans,tPreop,tPrere,nPat,allTime;</span><br><span class="line">Room opRooms[<span class="number">11</span>],reRooms[<span class="number">31</span>];</span><br><span class="line">Patient pats[<span class="number">101</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">patComp</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="type">const</span> Patient&amp; p1 = pats[l];</span><br><span class="line">		<span class="type">const</span> Patient&amp; p2 = pats[r];</span><br><span class="line">		<span class="keyword">return</span> p1.opID &lt; p2.opID;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; opQueue,freeOpRooms,freeReRooms;</span><br><span class="line">set&lt;<span class="type">int</span>,patComp&gt;reQueue;</span><br></pre></td></tr></table></figure>

<p>这种模拟题目一个好的数据结构是比较重要的，类似于第一题</p>
<ul>
<li>这里面Room的pat默认是-1，也可以不需要</li>
<li>关于事件的处理类似于第一个模拟题目，需要处理的事件就四种，手术室可用，手术室整理，康复室可用，康复室整理</li>
<li>关于reQueue队列，优先级是手术室号码低的优先级更高，原文是这样描述的（After surgery, a patient is taken to the available recovery room bed with the lowest number. If two patients emerge from surgery at the same time, the patient with the lower number will be the first assigned to a recovery room bed. (If in addition the two patients entered surgery at the same time, the one first on the roster is first assigned a bed.)）；而其他三个队列都是id小，优先级更高</li>
</ul>
<p>2.关于打印</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">output&lt;&lt;<span class="string">&quot; Patient          Operating Room          Recovery Room\n&quot;</span>;</span><br><span class="line">output&lt;&lt;<span class="string">&quot; #  Name     Room#  Begin   End      Bed#  Begin    End\n&quot;</span>;</span><br><span class="line">output&lt;&lt;<span class="string">&quot; ------------------------------------------------------\n&quot;</span>;</span><br><span class="line">_for(i,<span class="number">0</span>,nPat)&#123;</span><br><span class="line">	output&lt;&lt;<span class="built_in">setw</span>(<span class="number">2</span>)&lt;&lt;i+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">Pout</span>(pats[i]);</span><br><span class="line">&#125;</span><br><span class="line">output&lt;&lt;<span class="string">&quot;\nFacility Utilization\n&quot;</span>;</span><br><span class="line">output&lt;&lt;<span class="string">&quot;Type  # Minutes  % Used\n&quot;</span>;</span><br><span class="line">output&lt;&lt;<span class="string">&quot;-------------------------\n&quot;</span>;</span><br><span class="line">_for(i,<span class="number">0</span>,nOP)&#123;</span><br><span class="line">	output&lt;&lt;<span class="string">&quot;Room &quot;</span>&lt;&lt;<span class="built_in">setw</span>(<span class="number">2</span>)&lt;&lt;i+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">Rout</span>(opRooms[i]);</span><br><span class="line">&#125;</span><br><span class="line">_for(i,<span class="number">0</span>,nRE)&#123;</span><br><span class="line">	output&lt;&lt;<span class="string">&quot;Bed  &quot;</span>&lt;&lt;<span class="built_in">setw</span>(<span class="number">2</span>)&lt;&lt;i+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">Rout</span>(reRooms[i]);</span><br><span class="line">&#125;</span><br><span class="line">output&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writeTime</span><span class="params">(<span class="type">char</span>* buf,<span class="type">int</span> time)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> h = T0 + time/<span class="number">60</span>,m = time % <span class="number">60</span>;</span><br><span class="line">	<span class="built_in">sprintf</span>(buf,<span class="string">&quot;%2d:%02d&quot;</span>,h,m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pout</span><span class="params">(<span class="type">const</span> Patient&amp; p)</span></span>&#123;</span><br><span class="line">	<span class="comment">//  char buf[16];</span></span><br><span class="line">    <span class="comment">// sprintf(buf, &quot;  %-10s%2d   &quot;, p.name.c_str(), p.opRoomId+1); os&lt;&lt;buf;</span></span><br><span class="line">    <span class="comment">// writeTime(buf, p.opBeginTime); os&lt;&lt;buf&lt;&lt;&quot;   &quot;;</span></span><br><span class="line">    <span class="comment">// writeTime(buf, p.opEndTime); os&lt;&lt;buf;</span></span><br><span class="line">    <span class="comment">// sprintf(buf, &quot;%7d&quot;, p.reRoomId+1); os&lt;&lt;buf&lt;&lt;&quot;   &quot;;</span></span><br><span class="line">    <span class="comment">// writeTime(buf, p.reBeginTime); os&lt;&lt;buf&lt;&lt;&quot;   &quot;;</span></span><br><span class="line">    <span class="comment">// writeTime(buf, p.reEndTime); os&lt;&lt;buf;</span></span><br><span class="line">    <span class="comment">// return os;</span></span><br><span class="line">	<span class="type">char</span> buf[<span class="number">16</span>];</span><br><span class="line">	<span class="built_in">sprintf</span>(buf, <span class="string">&quot;  %-10s%2d   &quot;</span>, p.name.<span class="built_in">c_str</span>(), p.opID+<span class="number">1</span>); output&lt;&lt;buf;</span><br><span class="line">	<span class="built_in">writeTime</span>(buf, p.opBT); output&lt;&lt;buf&lt;&lt;<span class="string">&quot;   &quot;</span>;</span><br><span class="line">    <span class="built_in">writeTime</span>(buf, p.opET); output&lt;&lt;buf;</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%7d&quot;</span>, p.reId+<span class="number">1</span>); output&lt;&lt;buf&lt;&lt;<span class="string">&quot;   &quot;</span>;</span><br><span class="line">    <span class="built_in">writeTime</span>(buf, p.reBT); output&lt;&lt;buf&lt;&lt;<span class="string">&quot;   &quot;</span>;</span><br><span class="line">    <span class="built_in">writeTime</span>(buf, p.reET); output&lt;&lt;buf&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Rout</span><span class="params">(<span class="type">const</span> Room&amp; r)</span></span>&#123;</span><br><span class="line">	<span class="comment">// double p = r.minutes * 100;</span></span><br><span class="line">    <span class="comment">// p /= allTime;</span></span><br><span class="line">    <span class="comment">// char buf[64];</span></span><br><span class="line">    <span class="comment">// sprintf(buf, &quot;%8d   %5.2lf&quot;, r.minutes, p);</span></span><br><span class="line">    <span class="comment">// return os&lt;&lt;buf;</span></span><br><span class="line">	<span class="type">double</span> p = r.minutes * <span class="number">100</span>;</span><br><span class="line">	p /= allTime;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">	<span class="built_in">sprintf</span>(buf, <span class="string">&quot;%8d   %5.2lf&quot;</span>, r.minutes, p);</span><br><span class="line">	output&lt;&lt;buf&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这里是比较麻烦的地方，因为打印出的格式需要自己去观察，但实际上还是比较复杂的，难以想象这种二十年前的ACM模拟题连打印格式处处埋坑。</p>
<p>3.初始化的过程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">freeOpRooms.<span class="built_in">clear</span>();</span><br><span class="line">freeReRooms.<span class="built_in">clear</span>();</span><br><span class="line">allTime = <span class="number">0</span>;</span><br><span class="line">cin&gt;&gt;nRE&gt;&gt;T0&gt;&gt;tTrans&gt;&gt;tPreop&gt;&gt;tPrere&gt;&gt;nPat;</span><br><span class="line">_for(i,<span class="number">0</span>,nOP)&#123;</span><br><span class="line">	em.<span class="built_in">push</span>(<span class="built_in">Event</span>(<span class="number">0</span>,i,opFree));</span><br><span class="line">	opRooms[i].<span class="built_in">init</span>();</span><br><span class="line">&#125;</span><br><span class="line">_for(i,<span class="number">0</span>,nRE)&#123;</span><br><span class="line">	em.<span class="built_in">push</span>(<span class="built_in">Event</span>(<span class="number">0</span>,i,reFree));</span><br><span class="line">	reRooms[i].<span class="built_in">init</span>();</span><br><span class="line">&#125;</span><br><span class="line">_for(i,<span class="number">0</span>,nPat)&#123;</span><br><span class="line">	Patient&amp; p = pats[i];</span><br><span class="line">	p.opID = <span class="number">-1</span>;</span><br><span class="line">	p.reId = <span class="number">-1</span>;</span><br><span class="line">	cin&gt;&gt;p.name&gt;&gt;p.sT&gt;&gt;p.rT;</span><br><span class="line">	opQueue.<span class="built_in">insert</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将医室压入事件队列，将病人压入待手术序列，其中将病人的房间id置为-1,我猜测在调试的时候可能方便查找错误</li>
</ul>
<p>4.队列模拟过程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> time = em.<span class="built_in">top</span>().time;</span><br><span class="line">	<span class="keyword">while</span>(!em.<span class="built_in">empty</span>() &amp;&amp; em.<span class="built_in">top</span>().time == time)&#123;</span><br><span class="line">		Event e = em.<span class="built_in">top</span>();</span><br><span class="line">		em.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="type">int</span> pid;</span><br><span class="line">		<span class="keyword">switch</span>(e.type)&#123;</span><br><span class="line">			<span class="keyword">case</span> opFree:</span><br><span class="line">				freeOpRooms.<span class="built_in">insert</span>(e.id);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> opPre:</span><br><span class="line">				pid = opRooms[e.id].pat;</span><br><span class="line">				reQueue.<span class="built_in">insert</span>(pid);</span><br><span class="line">				opRooms[e.id].pat = <span class="number">-1</span>;</span><br><span class="line">				em.<span class="built_in">push</span>(<span class="built_in">Event</span>(time+tPreop,e.id,opFree));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> reFree:</span><br><span class="line">				freeReRooms.<span class="built_in">insert</span>(e.id);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> rePre:</span><br><span class="line">				reRooms[e.id].pat = <span class="number">-1</span>;</span><br><span class="line">				em.<span class="built_in">push</span>(<span class="built_in">Event</span>(time+tPrere,e.id,reFree));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> opSz = <span class="built_in">min</span>(opQueue.<span class="built_in">size</span>(),freeOpRooms.<span class="built_in">size</span>());</span><br><span class="line">	_for(i,<span class="number">0</span>,opSz)&#123;</span><br><span class="line">		<span class="type">int</span> pid = *(opQueue.<span class="built_in">begin</span>());</span><br><span class="line">		opQueue.<span class="built_in">erase</span>(opQueue.<span class="built_in">begin</span>());</span><br><span class="line">		<span class="type">int</span> rid = *(freeOpRooms.<span class="built_in">begin</span>());</span><br><span class="line">		freeOpRooms.<span class="built_in">erase</span>(freeOpRooms.<span class="built_in">begin</span>());</span><br><span class="line">        </span><br><span class="line">		Room&amp; r = opRooms[rid];</span><br><span class="line">		r.pat = pid;</span><br><span class="line">		Patient&amp; p = pats[pid];</span><br><span class="line">		p.opID = rid;</span><br><span class="line">		p.opBT = time;</span><br><span class="line">		p.opET = time + p.sT;</span><br><span class="line">		r.minutes += p.sT;</span><br><span class="line">		em.<span class="built_in">push</span>(<span class="built_in">Event</span>(p.opET,rid,opPre));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> reSz = <span class="built_in">min</span>(reQueue.<span class="built_in">size</span>(),freeReRooms.<span class="built_in">size</span>());</span><br><span class="line">	_for(i,<span class="number">0</span>,reSz)&#123;</span><br><span class="line">		<span class="type">int</span> pid = *(reQueue.<span class="built_in">begin</span>());</span><br><span class="line">		reQueue.<span class="built_in">erase</span>(reQueue.<span class="built_in">begin</span>());</span><br><span class="line">		<span class="type">int</span> rid = *(freeReRooms.<span class="built_in">begin</span>());</span><br><span class="line">		freeReRooms.<span class="built_in">erase</span>(freeReRooms.<span class="built_in">begin</span>());</span><br><span class="line">		Room&amp; r = reRooms[rid];</span><br><span class="line">		r.pat = pid;</span><br><span class="line">		Patient&amp; p = pats[pid];</span><br><span class="line">		p.reId = rid;</span><br><span class="line">		p.reBT = time + tTrans;</span><br><span class="line">		p.reET = p.reBT + p.rT;</span><br><span class="line">		r.minutes += p.rT;</span><br><span class="line">		em.<span class="built_in">push</span>(<span class="built_in">Event</span>(p.reET,rid,rePre));</span><br><span class="line">		allTime = <span class="built_in">max</span>(allTime,p.reET);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>首先将在该时刻发生的事情归类</p>
<ul>
<li>如果是出现了空闲的手术室，将这个手术室压入空闲手术室队列</li>
<li>如果是出现了待准备的手术室，意味着手术刚做完，那么手术室中的病人将会进入康复室，所以要将其压入等待康复室队列，同时压入事件，意味着当准备之后，将会出现一个空闲的手术室<ul>
<li>这里有一个细节，病人是在运送之前就已经到进入等待康复室的队列，而不是在运送之后才到达的康复室队列</li>
</ul>
</li>
<li>如果是出现了空闲的康复室，那么将这个康复室压入空闲手术室队列</li>
<li>如果是出现了待准备的康复室，意味着已经有病人康复完，那么在准备时间之后，又会出现一个空闲的康复室</li>
</ul>
</li>
<li><p>对于空闲手术室，康复室的分配</p>
<ul>
<li>对于手术室，手术室会记录下分配病人的id，这一点很重要，因为当手术做完之后病人要进入reQueue;同时不仅病人对应的手术室的id被记录，病人的手术开始时间，结束时间，手术室的工作时间也都是在这个时候被记录的，同时手术时间之后一个待prepare的手术室也压入Event中<ul>
<li>其实这个结束时间按自然的想法来说应该是手术结束之后才被记录，但此时被记录一是因为条件是足够的，二是能记录就记录，避免被遗忘</li>
</ul>
</li>
<li>对于康复室，也是类似的。康复室会记录下分配病人的id;同时不仅病人对应的康复室的id被记录，病人的康复开始时间（注意这里中间还有一个转运时间），结束时间，康复室的工作时间也都是在这个时候被记录的，同时康复时间之后一个待prepare的康复室也压入Event中，不同的是这里要记录下最后一个病人出康复室的时间</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/10/05/23-10-5/" data-id="clnq01c0f00045gjdaywl5e1o" data-title="23.10.5" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%A8%A1%E6%8B%9F/" rel="tag">模拟</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2023/10/08/23-10-8/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          23.10.8
        
      </div>
    </a>
  
  
    <a href="/2023/10/03/23-10-3/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">23.10.3-10.4</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BF%83%E6%83%85/">心情</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C%E7%9B%98%E6%B8%85%E7%90%86/" rel="tag">C盘清理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E6%9E%90/" rel="tag">分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9A%B4%E5%8A%9B%E6%90%9C%E7%B4%A2/" rel="tag">暴力搜索</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A8%A1%E6%8B%9F/" rel="tag">模拟</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/" rel="tag">算法练习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%AB%98%E6%95%88%E7%AE%97%E6%B3%95/" rel="tag">高效算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%AB%98%E6%95%88%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/" rel="tag">高效算法设计</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C%E7%9B%98%E6%B8%85%E7%90%86/" style="font-size: 10px;">C盘清理</a> <a href="/tags/%E5%88%86%E6%9E%90/" style="font-size: 20px;">分析</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">数据结构</a> <a href="/tags/%E6%9A%B4%E5%8A%9B%E6%90%9C%E7%B4%A2/" style="font-size: 20px;">暴力搜索</a> <a href="/tags/%E6%A8%A1%E6%8B%9F/" style="font-size: 20px;">模拟</a> <a href="/tags/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/" style="font-size: 10px;">算法练习</a> <a href="/tags/%E9%AB%98%E6%95%88%E7%AE%97%E6%B3%95/" style="font-size: 10px;">高效算法</a> <a href="/tags/%E9%AB%98%E6%95%88%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/" style="font-size: 10px;">高效算法设计</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">September 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/10/22/23-10-22/">23.10.22</a>
          </li>
        
          <li>
            <a href="/2023/10/20/23-10-20/">23.10.20</a>
          </li>
        
          <li>
            <a href="/2023/10/19/23-10-19/">23.10.19</a>
          </li>
        
          <li>
            <a href="/2023/10/18/23-10-18/">23.10.18</a>
          </li>
        
          <li>
            <a href="/2023/10/14/23-10-14/">23.10.14</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>