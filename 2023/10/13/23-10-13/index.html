<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>23.10.13 | experience sharing</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="暴力搜索">
<meta property="og:type" content="article">
<meta property="og:title" content="23.10.13">
<meta property="og:url" content="http://example.com/2023/10/13/23-10-13/index.html">
<meta property="og:site_name" content="experience sharing">
<meta property="og:description" content="暴力搜索">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-10-13T06:42:48.000Z">
<meta property="article:modified_time" content="2023-10-14T12:12:43.853Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="暴力搜索">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="experience sharing" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">experience sharing</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">xu jian</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-23-10-13" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/10/13/23-10-13/" class="article-date">
  <time class="dt-published" datetime="2023-10-13T06:42:48.000Z" itemprop="datePublished">2023-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      23.10.13
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="暴力搜索"><a href="#暴力搜索" class="headerlink" title="暴力搜索"></a>暴力搜索</h1><span id="more"></span>

<h3 id="1-Guarding-the-Chessboard"><a href="#1-Guarding-the-Chessboard" class="headerlink" title="1.Guarding the Chessboard"></a>1.Guarding the Chessboard</h3><p>题目链接:<a target="_blank" rel="noopener" href="https://vjudge.net/problem/UVA-11214">Guarding the Chessboard - UVA 11214 - Virtual Judge (vjudge.net)</a></p>
<p>解析:</p>
<ol>
<li></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="built_in">Point</span>(<span class="type">int</span> x = <span class="number">0</span>,<span class="type">int</span> y = <span class="number">0</span>):<span class="built_in">x</span>(x),<span class="built_in">y</span>(y)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXM = <span class="number">9</span>;</span><br><span class="line">Point <span class="keyword">operator</span>+(<span class="type">const</span> Point&amp; a,<span class="type">const</span> Point&amp; b)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Point</span>(a.x+b.x,a.y+b.y);</span><br><span class="line">&#125;</span><br><span class="line">Point dirs[] = &#123;</span><br><span class="line">	&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(<span class="type">const</span> Point&amp; p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> p.x &gt;= <span class="number">0</span> &amp;&amp; p.x &lt; n &amp;&amp; p.y &gt;= <span class="number">0</span> &amp;&amp; p.y &lt; m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Grid</span>&#123;</span><br><span class="line">    <span class="type">int</span> bits[<span class="number">4</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;<span class="built_in">memset</span>(bits,<span class="number">0</span>,<span class="built_in">sizeof</span>(bits));&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> r,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> l = r*m +c;</span><br><span class="line">        bits[l/<span class="number">32</span>] |= (<span class="number">1</span>&lt;&lt;(l&amp;<span class="number">31</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">canCover</span><span class="params">(<span class="type">const</span> Grid&amp; g)</span><span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (bits[<span class="number">0</span>] &amp; g.bits[<span class="number">0</span>]) == g.bits[<span class="number">0</span>]</span><br><span class="line">        &amp;&amp; (bits[<span class="number">1</span>] &amp; g.bits[<span class="number">1</span>]) == g.bits[<span class="number">1</span>]</span><br><span class="line">        &amp;&amp; (bits[<span class="number">2</span>] &amp; g.bits[<span class="number">2</span>]) == g.bits[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Grid</span>()&#123;<span class="built_in">clear</span>();&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Grid covers[MAXM*MAXM+<span class="number">3</span>],target;</span><br></pre></td></tr></table></figure>

<ul>
<li>Grid3个bit位就可以了</li>
<li>将二维的位置转化为一维的位置，然后用l的后五位bit数字以及l是32的多少倍，来决定将这个状态设置到96的bit中的哪一个。</li>
<li>canCover则判断g中所覆盖的点数是否是该位置所覆盖点数的子集</li>
</ul>
<ol start="2">
<li></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">string line;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>;cin&gt;&gt;n&gt;&gt;m &amp;&amp; n &amp;&amp; m;k++)&#123;</span><br><span class="line">        target.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">memset</span>(covers,<span class="number">0</span>,<span class="built_in">sizeof</span>(covers));</span><br><span class="line">        _for(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">            cin&gt;&gt;line;</span><br><span class="line">            _for(j,<span class="number">0</span>,m)&#123;</span><br><span class="line">                <span class="keyword">if</span>(line[j] == <span class="string">&#x27;X&#x27;</span>)target.<span class="built_in">set</span>(i,j);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; dv:dirs)&#123;</span><br><span class="line">                    <span class="function">Point <span class="title">pc</span><span class="params">(i,j)</span></span>;</span><br><span class="line">                    <span class="keyword">while</span>(<span class="built_in">isValid</span>(pc))&#123;</span><br><span class="line">                        covers[i*m+j].<span class="built_in">set</span>(pc.x,pc.y);</span><br><span class="line">                        pc = pc + dv;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> best = <span class="number">6</span>;</span><br><span class="line">        Grid g;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,g,<span class="number">0</span>,best);</span><br><span class="line">        output&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;k&lt;&lt;<span class="string">&quot;: &quot;</span>&lt;&lt;best&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将目标点的状态建立好，将每个点假设作为皇后所能覆盖到的点的状态设置好</li>
<li>难不成最多的皇后数是6个吗？题目中貌似没有提及，或者说6个皇后就能覆盖整个9*9棋盘的任意位置？</li>
</ul>
<ol start="3">
<li></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> ci,<span class="type">const</span> Grid&amp; g,<span class="type">int</span> depth,<span class="type">int</span>&amp; best)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(depth &gt;= best)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(g.<span class="built_in">canCover</span>(target))&#123;</span><br><span class="line">        best = <span class="built_in">min</span>(best,depth);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ci &gt; n*m || depth + <span class="number">1</span> &gt; best)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(ci+<span class="number">1</span>,g,depth,best);</span><br><span class="line">    Grid ng = g;</span><br><span class="line">    <span class="type">int</span> *cb = covers[ci].bits;</span><br><span class="line">    ng.bits[<span class="number">0</span>] |= cb[<span class="number">0</span>],</span><br><span class="line">    ng.bits[<span class="number">1</span>] |= cb[<span class="number">1</span>],</span><br><span class="line">    ng.bits[<span class="number">2</span>] |= cb[<span class="number">2</span>],</span><br><span class="line">    <span class="built_in">dfs</span>(ci+<span class="number">1</span>,ng,depth+<span class="number">1</span>,best);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ci代表皇后的位置，g代表棋盘当前的状态，depth代表目前皇后的个数，best代表最佳皇后的个数</li>
<li>如果说当前皇后的个数大于等于皇后的个数，意味着不是最佳方案，直接中断</li>
<li>如果当前的棋盘状态能够覆盖目标的棋盘状态，意味是方案成功，更新最佳皇后个数</li>
<li>如果每个位置都尝试过了一遍，那么中断即可（判断条件写的并不严谨）</li>
<li>然后每个位置有两种情况，这个位置放置了皇后，这个位置没有放置皇后</li>
</ul>
<h3 id="2-Planning-mobile-robot-on-Tree-EASY-Version"><a href="#2-Planning-mobile-robot-on-Tree-EASY-Version" class="headerlink" title="2.Planning mobile robot on Tree (EASY Version)"></a>2.Planning mobile robot on Tree (EASY Version)</h3><p>题目链接:<a target="_blank" rel="noopener" href="https://vjudge.net/problem/UVA-12569">Planning mobile robot on Tree (EASY Version) - UVA 12569 - Virtual Judge (vjudge.net)</a></p>
<p>解析:</p>
<ol>
<li></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> K;</span><br><span class="line">    cin&gt;&gt;K;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">1</span>;t &lt;= K;t++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(VIS,<span class="number">0</span>,<span class="built_in">sizeof</span>(VIS));</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;m&gt;&gt;S&gt;&gt;T;</span><br><span class="line">        --S;--T;</span><br><span class="line">        output&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;t&lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">        _for(i,<span class="number">0</span>,m)&#123;</span><br><span class="line">            <span class="type">int</span> x;cin&gt;&gt;x;x--;</span><br><span class="line">            O[i] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        _for(i,<span class="number">0</span>,n)G[i].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="comment">//n个点有n-1条边</span></span><br><span class="line">        _for(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> u,v;</span><br><span class="line">            cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">            u--,v--;</span><br><span class="line">            G[u].<span class="built_in">push_back</span>(v),G[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">        pool.<span class="built_in">dispose</span>();</span><br><span class="line">        output&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将有障碍物的点记录下来</li>
<li>因为是树，所以n个点会有n条边，然后将边记录下来</li>
</ul>
<ol start="2">
<li></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MemPool</span>&#123;</span><br><span class="line">    vector&lt;T*&gt;buf;</span><br><span class="line">    <span class="function">T*<span class="title">createNew</span><span class="params">()</span></span>&#123;</span><br><span class="line">        buf.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">T</span>());</span><br><span class="line">        <span class="keyword">return</span> buf.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dispose</span><span class="params">()</span></span>&#123;</span><br><span class="line">        _for(i,<span class="number">0</span>,buf.<span class="built_in">size</span>())<span class="keyword">delete</span> buf[i];</span><br><span class="line">        buf.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> from,to;</span><br><span class="line">    Node* next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">State</span>&#123;</span><br><span class="line">    Node* path;</span><br><span class="line">    <span class="type">int</span> g,len;</span><br><span class="line">    <span class="built_in">State</span>(<span class="type">int</span> gi = <span class="number">0</span>,<span class="type">int</span> li = <span class="number">0</span>,Node* pn = <span class="literal">NULL</span>):<span class="built_in">g</span>(gi),<span class="built_in">len</span>(li),<span class="built_in">path</span>(pn)&#123;&#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>[](<span class="type">size_t</span> i)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> g&amp;(<span class="number">1</span>&lt;&lt;(i+<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">setRock</span><span class="params">(<span class="type">size_t</span> i,<span class="type">bool</span> val = <span class="literal">true</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(val) g |= <span class="number">1</span>&lt;&lt;(i+<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">else</span> g &amp;= ~(<span class="number">1</span>&lt;&lt;(i+<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getP</span><span class="params">()</span><span class="type">const</span> </span>&#123;<span class="keyword">return</span> g&amp;<span class="number">15</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">setP</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;g = ((g&gt;&gt;<span class="number">4</span>)&lt;&lt;<span class="number">4</span>)|p;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;G[MAXN];</span><br><span class="line">MemPool&lt;Node&gt; pool;</span><br><span class="line"><span class="type">int</span> n,m,S,T,O[MAXN],VIS[<span class="number">1</span>&lt;&lt;<span class="number">19</span>];</span><br><span class="line"><span class="function">Node* <span class="title">newNode</span><span class="params">(Node* next = <span class="literal">NULL</span>,<span class="type">int</span> u = <span class="number">-1</span>,<span class="type">int</span> v = <span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">    Node* p = pool.<span class="built_in">createNew</span>();</span><br><span class="line">    p-&gt;next = next,p-&gt;from = u,p-&gt;to = v;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line">stringstream&amp; <span class="keyword">operator</span>&lt;&lt;(stringstream&amp; ss,Node* p)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)<span class="keyword">return</span> ss;</span><br><span class="line">    ss&lt;&lt;p-&gt;next&lt;&lt;p-&gt;from+<span class="number">1</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;p-&gt;to+<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Node结构体，MemPool，以及stringstream类的重写都是服务于答案路径的输出</p>
</li>
<li><p>State中，g的后四位用于表示机器人的位置，getP和setP都和机器人的位置相关</p>
</li>
<li><p>g的前几位则表示障碍物的位置[]符号的重载，setRock均和障碍物的位置有关</p>
</li>
<li><p>在&lt;&lt;符号的打印中，其实是用了递归的思想，因为路径的开头在链表的最后面，所以</p>
<p>p-&gt;next是最先打印的</p>
</li>
</ul>
<ol start="3">
<li></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tryMove</span><span class="params">(<span class="type">const</span> State&amp; s,<span class="type">int</span> from,queue&lt;State&gt;&amp; q)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> rp = s.<span class="built_in">getP</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> to : G[from])&#123;</span><br><span class="line">        <span class="keyword">if</span>(to == rp || s[to])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> ng = s.g;</span><br><span class="line">        <span class="keyword">if</span>(from == rp)ng = ((s.g&gt;&gt;<span class="number">4</span>)&lt;&lt;<span class="number">4</span>) | to;</span><br><span class="line">        <span class="keyword">else</span> ng ^= (<span class="number">1</span>&lt;&lt;(from+<span class="number">4</span>)),ng ^= (<span class="number">1</span>&lt;&lt;(to+<span class="number">4</span>));</span><br><span class="line">        <span class="keyword">if</span>(VIS[ng])<span class="keyword">continue</span>;</span><br><span class="line">        VIS[ng] = <span class="number">1</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">State</span>(ng,s.len+<span class="number">1</span>,<span class="built_in">newNode</span>(s.path,from,to)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    State s;</span><br><span class="line">    _for(i,<span class="number">0</span>,m)s.<span class="built_in">setRock</span>(O[i]);</span><br><span class="line">    s.<span class="built_in">setP</span>(S);</span><br><span class="line">    queue&lt;State&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    VIS[s.g] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">const</span> State&amp; st = q.<span class="built_in">front</span>();</span><br><span class="line">        <span class="type">int</span> rp = st.<span class="built_in">getP</span>();</span><br><span class="line">        <span class="keyword">if</span>(rp == T)&#123;</span><br><span class="line">            output&lt;&lt;st.len&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            stringstream ss;</span><br><span class="line">            ss&lt;&lt;st.path;</span><br><span class="line">            output&lt;&lt;ss.<span class="built_in">str</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">tryMove</span>(st,rp,q);</span><br><span class="line">        _for(i,<span class="number">0</span>,n)<span class="keyword">if</span>(st[i])<span class="built_in">tryMove</span>(st,i,q);</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    output&lt;&lt;<span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>将初始状态压入队列</p>
</li>
<li><p>如果当前机器人的地点和目标地点相同，那么就打印出路径的长度和路径</p>
</li>
<li><p>否则就去尝试移动机器人</p>
<ul>
<li>如果目前能移到的位置是障碍物，那么就不能移动</li>
<li>如果移动前的位置就是机器人的位置，那么要维护机器人的位置</li>
<li>看这个状态是否经历过，如果没有经历过就压队列，并且更新VIS数组</li>
</ul>
</li>
<li><p>还可以尝试移动障碍物</p>
<ul>
<li>如果目前能移到的位置是机器人，那么就不能移动</li>
<li>如果移动前的位置是障碍物的位置，那么要维护障碍物的位置</li>
<li>看这个状态是否经历过，如果没有经历过就压队列，并且更新VIS数组</li>
</ul>
</li>
<li><p>其实在压入队列的时候，新的Node创建的时候就是连接着原有的路径的。</p>
</li>
<li><p>在每一步，都有m+1种决策，在最后，链表的结构将会变的非常的复杂，但是链表的终点只有一个</p>
</li>
</ul>
<h3 id="3-Moving-Pegs"><a href="#3-Moving-Pegs" class="headerlink" title="3.Moving Pegs"></a>3.Moving Pegs</h3><p>题目连接：<a target="_blank" rel="noopener" href="https://vjudge.net/problem/UVA-1533">Moving Pegs - UVA 1533 - Virtual Judge (vjudge.net)</a></p>
<p>解析:</p>
<ol>
<li></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">stringstream&amp; <span class="keyword">operator</span>&lt;&lt;(stringstream&amp; ss,<span class="type">const</span> vector&lt;T&gt;&amp; v)&#123;</span><br><span class="line">   <span class="type">bool</span> first = <span class="literal">true</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; e : v)&#123;</span><br><span class="line">    <span class="keyword">if</span>(first)first = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> ss&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    ss&lt;&lt;e;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> ss;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这些都是某个位置相邻的位置</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">15</span>,D = <span class="number">6</span>,DIRS[N+<span class="number">1</span>][D] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> &#125;,</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span> &#125;, <span class="comment">// 1 </span></span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;, <span class="comment">// 2</span></span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">6</span> &#125;, <span class="comment">// 3</span></span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span> &#125;, <span class="comment">// 4</span></span><br><span class="line">    &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span> &#125;, <span class="comment">// 5</span></span><br><span class="line">    &#123;<span class="number">3</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">10</span> &#125;, <span class="comment">// 6</span></span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">12</span> &#125;, <span class="comment">// 7</span></span><br><span class="line">    &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">13</span> &#125;, <span class="comment">// 8</span></span><br><span class="line">    &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">14</span> &#125;, <span class="comment">// 9</span></span><br><span class="line">    &#123;<span class="number">6</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">14</span>,<span class="number">15</span> &#125;, <span class="comment">// 10</span></span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">0</span> &#125;, <span class="comment">// 11</span></span><br><span class="line">    &#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">0</span>,<span class="number">0</span> &#125;, <span class="comment">// 12</span></span><br><span class="line">    &#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">0</span>,<span class="number">0</span> &#125;, <span class="comment">// 13</span></span><br><span class="line">    &#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="number">0</span> &#125;, <span class="comment">// 14</span></span><br><span class="line">    &#123;<span class="number">10</span>,<span class="number">0</span>,<span class="number">14</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> &#125; <span class="comment">// 15</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Board</span>&#123;</span><br><span class="line">   <span class="type">int</span> pos,cnt;</span><br><span class="line">   vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">   <span class="built_in">Board</span>()&#123;pos = ~<span class="number">0</span>;cnt = N;&#125;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    pos ^= (<span class="number">1</span>&lt;&lt;i);cnt--;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    pos |= (<span class="number">1</span>&lt;&lt;i);cnt++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="type">bool</span> <span class="title">test</span><span class="params">(<span class="type">int</span> i)</span><span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (pos&amp;(<span class="number">1</span>&lt;&lt;i)) != <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">findJump</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> d)</span><span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> j = DIRS[i][d];</span><br><span class="line">        <span class="keyword">if</span>(!j || !<span class="built_in">test</span>(j))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; <span class="built_in">test</span>(j))j = DIRS[j][d];</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>统共有15个洞，将每个洞每个方向相邻的洞的标号都打印了出来，是0意味着越界</li>
<li>clear，将对应的bit位置0；put，将对应的bit位置1</li>
<li>test，看某个洞上面是否有球</li>
<li>findJump,找到某个位置的某个方向最远能到的位置，最后所返回的值要么是空的位置，要么是0（越界）</li>
</ul>
<ol start="2">
<li></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> e)</span></span>&#123;</span><br><span class="line">    Board ib;ib.<span class="built_in">clear</span>(e);</span><br><span class="line">    queue&lt;Board&gt; q;q.<span class="built_in">push</span>(ib);</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; vis;vis.<span class="built_in">insert</span>(ib.pos);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        Board b = q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(b.cnt == <span class="number">1</span>&amp;&amp; b.<span class="built_in">test</span>(e))&#123;</span><br><span class="line">            output&lt;&lt;b.path.<span class="built_in">size</span>()/<span class="number">2</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            stringstream ss;</span><br><span class="line">            ss&lt;&lt;b.path&lt;&lt;endl;</span><br><span class="line">            output&lt;&lt;ss.<span class="built_in">str</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= N;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!b.<span class="built_in">test</span>(i))<span class="keyword">continue</span>;</span><br><span class="line">            _for(d,<span class="number">0</span>,D)&#123;</span><br><span class="line">                <span class="type">int</span> t = b.<span class="built_in">findJump</span>(i,d);</span><br><span class="line">                <span class="keyword">if</span>(!t)<span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> j = DIRS[i][d];</span><br><span class="line">                Board nb = b;</span><br><span class="line">                nb.<span class="built_in">clear</span>(i);</span><br><span class="line">                <span class="keyword">while</span>(j != t)nb.<span class="built_in">clear</span>(j),j = DIRS[j][d];</span><br><span class="line">                nb.<span class="built_in">put</span>(t);</span><br><span class="line">                <span class="keyword">if</span>(vis.<span class="built_in">count</span>(nb.pos))<span class="keyword">continue</span>;</span><br><span class="line">                vis.<span class="built_in">insert</span>(nb.pos);</span><br><span class="line">                nb.path.<span class="built_in">push_back</span>(i);</span><br><span class="line">                nb.path.<span class="built_in">push_back</span>(t);</span><br><span class="line">                q.<span class="built_in">push</span>(nb);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    output&lt;&lt;<span class="string">&quot;IMPOSSIBLE\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>初始化最初的状态，将最初的状态压入队列，并且更新Vis</li>
<li>如果说当前状态只有1个棋子并且最初的空洞上面有球，意味着找到了方案</li>
<li>否则就去找有球的孔洞去尝试<ul>
<li>遍历每一个方向<ul>
<li>如果这个方向能跳到一个不是0的位置，那么就把起点和终点中间的位置全部清空掉，并且将起点的球至于终点上</li>
<li>如果说这个棋盘的状态是重复的，那么就抛弃掉这种情况</li>
<li>否则就把这个状态插入set，push进队列，记录下答案</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-Biggest-Number"><a href="#4-Biggest-Number" class="headerlink" title="4.Biggest Number"></a>4.Biggest Number</h3><p>题目链接:<a target="_blank" rel="noopener" href="https://vjudge.net/problem/UVA-11882">Biggest Number - UVA 11882 - Virtual Judge (vjudge.net)</a></p>
<p>解析:</p>
<ol>
<li></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXR = <span class="number">32</span>,MAXC = <span class="number">32</span>;</span><br><span class="line"><span class="type">int</span> R,C,Walked[MAXR][MAXC],Vis[MAXR][MAXC],</span><br><span class="line">DX[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,DY[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">char</span> Grid[MAXR][MAXC];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isValid</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> &lt;= x&amp;&amp; x &lt; R &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; C &amp;&amp; <span class="built_in">isdigit</span>(Grid[x][y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rec</span>&#123;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; buf;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Rec&amp; r)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(buf.<span class="built_in">size</span>() != r.buf.<span class="built_in">size</span>())<span class="keyword">return</span> buf.<span class="built_in">size</span>() &lt; r.buf.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> buf &lt; r.buf;</span><br><span class="line">    &#125;</span><br><span class="line">    Rec&amp; <span class="keyword">operator</span> += (<span class="type">const</span> Rec&amp; r)&#123;</span><br><span class="line">        <span class="type">int</span> sz = buf.<span class="built_in">size</span>();</span><br><span class="line">        buf.<span class="built_in">resize</span>(buf.<span class="built_in">size</span>() + r.buf.<span class="built_in">size</span>());</span><br><span class="line">        <span class="built_in">copy_backward</span>(<span class="built_in">begin</span>(r.buf),<span class="built_in">end</span>(r.buf),<span class="built_in">begin</span>(buf)+sz);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Rec&amp; <span class="keyword">operator</span> +=(<span class="type">char</span> c)&#123;</span><br><span class="line">        buf.<span class="built_in">push_back</span>(c);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">size</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buf.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        buf.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printLn</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">        _for(i,<span class="number">0</span>,<span class="built_in">size</span>())&#123;</span><br><span class="line">            output&lt;&lt;buf[i];</span><br><span class="line">        &#125;</span><br><span class="line">        output&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>对于char vector实现字符的拼接，可以使用copy_backward</li>
</ul>
<ol start="2">
<li></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,Rec&amp; r)</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(x*MAXC+y);</span><br><span class="line">    <span class="built_in">memset</span>(Vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(Vis));</span><br><span class="line">    Vis[x][y] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> tmp = q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        x = tmp / MAXC,y = tmp %= MAXC;</span><br><span class="line">        _for(i,<span class="number">0</span>,<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="type">int</span> ax = x + DX[i],ay = y + DY[i];</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">isValid</span>(ax,ay) || Walked[ax][ay] || Vis[ax][ay])<span class="keyword">continue</span>;</span><br><span class="line">            Vis[ax][ay] = <span class="number">1</span>;</span><br><span class="line">            r += Grid[ax][ay];</span><br><span class="line">            q.<span class="built_in">push</span>(ax*MAXC+ay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lessThan</span><span class="params">(<span class="type">const</span> Rec&amp; r1, Rec&amp; r2,<span class="type">const</span> Rec&amp; t)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>,a,b;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; r1.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        a = r1.buf[i],b = t.buf[i];</span><br><span class="line">        <span class="keyword">if</span>(a &lt; b)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(b &lt; a)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(r2.buf.<span class="built_in">begin</span>(),r2.buf.<span class="built_in">end</span>(),<span class="built_in">greater</span>&lt;<span class="type">char</span>&gt;());</span><br><span class="line">    <span class="keyword">for</span>(;i &lt; t.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        a = r2.buf[i-r1.<span class="built_in">size</span>()],b = t.buf[i];</span><br><span class="line">        <span class="keyword">if</span>(a &lt; b)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(a &gt; b)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>此bfs的作用仅仅是把目前所有的能够进队列的char都压进去，然后得到一条尽可能长的字符串，当然此字符串必定不是答案，只是为了剪枝优化</li>
<li>Vis数组专门为了bfs而开</li>
<li>lessThan用来比较r1+r2和t的大小，r1不可变，但是r2是可变的，其实r2就是由上面的bfs得到的，r2转化为最大和t的相应位数进行比较</li>
</ul>
<ol start="3">
<li></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,Rec&amp; cur,Rec&amp; ans)</span></span>&#123;</span><br><span class="line">    Rec rs;</span><br><span class="line">    <span class="built_in">bfs</span>(x,y,rs);</span><br><span class="line">    <span class="keyword">if</span>(cur.<span class="built_in">size</span>() + rs.<span class="built_in">size</span>() &lt; ans.<span class="built_in">size</span>())<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(cur.<span class="built_in">size</span>() + rs.<span class="built_in">size</span>() == ans.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">lessThan</span>(cur,rs,ans))<span class="keyword">return</span>;</span><br><span class="line">    _for(i,<span class="number">0</span>,<span class="number">4</span>)&#123;</span><br><span class="line">        <span class="type">int</span> ax = x + DX[i],ay = y+DY[i];</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">isValid</span>(ax,ay) || Walked[ax][ay])<span class="keyword">continue</span>;</span><br><span class="line">        cur += Grid[ax][ay];</span><br><span class="line">        Walked[ax][ay] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">solve</span>(ax,ay,cur,ans);</span><br><span class="line">        cur.buf.<span class="built_in">pop_back</span>();</span><br><span class="line">        Walked[ax][ay] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans &lt; cur)ans = cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// streambuf *cinbuf = cin.rdbuf();</span></span><br><span class="line">	<span class="comment">// cin.rdbuf(input.rdbuf());</span></span><br><span class="line">	Rec ans,cur;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;R&gt;&gt;C&amp;&amp; R&amp;&amp; C)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(Grid,<span class="number">0</span>,<span class="built_in">sizeof</span>(Grid));</span><br><span class="line">        <span class="built_in">memset</span>(Walked,<span class="number">0</span>,<span class="built_in">sizeof</span>(Walked));</span><br><span class="line">        _for(i,<span class="number">0</span>,R)cin&gt;&gt;Grid[i];</span><br><span class="line">        ans.<span class="built_in">clear</span>();</span><br><span class="line">        _for(i,<span class="number">0</span>,R)</span><br><span class="line">            _for(j,<span class="number">0</span>,C)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">isdigit</span>(Grid[i][j]))<span class="keyword">continue</span>;</span><br><span class="line">                cur.<span class="built_in">clear</span>(),cur += Grid[i][j];</span><br><span class="line">                Walked[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">solve</span>(i,j,cur,ans);</span><br><span class="line">                Walked[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        ans.<span class="built_in">printLn</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>会枚举每一个是数字的方格，对它进行深搜</li>
<li>每次深搜都会进行一次bfs,得到最多还能得到的字符串，和目前得到的字符串进行拼接与目前得到的最佳答案进行对比，倘若无论怎么样都比最佳答案还小，那么此次就没有必要继续进行</li>
<li>这里更新ans是每层dfs都要进行更新，而不是搜到底再更新</li>
</ul>
<h3 id="5-The-Wall-Pushers"><a href="#5-The-Wall-Pushers" class="headerlink" title="5.The Wall Pushers"></a>5.The Wall Pushers</h3><p>题目链接:<a target="_blank" rel="noopener" href="https://vjudge.net/problem/UVA-10384">The Wall Pushers - UVA 10384 - Virtual Judge (vjudge.net)</a></p>
<p>解析:</p>
<ol>
<li></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> R = <span class="number">4</span>,C = <span class="number">6</span>;</span><br><span class="line"><span class="type">const</span> <span class="built_in">string</span> DC = <span class="string">&quot;WNES&quot;</span>;</span><br><span class="line"><span class="type">int</span> DX[] = &#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,DY[] = &#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,REVD[] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x&amp;(<span class="number">1</span>&lt;&lt;b))&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> _set(<span class="type">int</span>&amp; x,<span class="type">int</span> b,<span class="type">bool</span> v)&#123;</span><br><span class="line">    <span class="keyword">if</span>(v) x |= (<span class="number">1</span>&lt;&lt;b);</span><br><span class="line">    <span class="keyword">else</span> x &amp;= ~(<span class="number">1</span>&lt;&lt;b);</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> Vis[R][C],cells[R][C];</span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsValid</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; R &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isExit</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="built_in">vector</span>&lt;<span class="type">char</span>&gt;&amp; path)</span>&#123;</span><br><span class="line">    <span class="type">int</span> p = cells[x][y];</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span> &amp;&amp; !get(p,<span class="number">1</span>))&#123;path.push_back(DC[<span class="number">1</span>]);<span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(y == <span class="number">0</span> &amp;&amp; !get(p,<span class="number">0</span>))&#123;path.push_back(DC[<span class="number">0</span>]);<span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(x == R<span class="number">-1</span> &amp;&amp; !get(p,<span class="number">3</span>))&#123;path.push_back(DC[<span class="number">3</span>]);<span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(y == C<span class="number">-1</span> &amp;&amp; !get(p,<span class="number">2</span>))&#123;path.push_back(DC[<span class="number">2</span>]);<span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>REVD是正常方向的反方向</li>
<li>get和set分别用来得到某点的某方向是否有墙以及来设置或者消除某方面的墙</li>
<li>这是判断该点是否是边界，以及该点是否是出口</li>
</ul>
<ol start="2">
<li></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sx,sy,maxd;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; path;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;sy&gt;&gt;sx&amp;&amp;sy&amp;&amp;sx)&#123;</span><br><span class="line">        _for(i,<span class="number">0</span>,R)</span><br><span class="line">            _for(j,<span class="number">0</span>,C)</span><br><span class="line">               cin&gt;&gt;cells[i][j];</span><br><span class="line">        sx--;sy--;maxd = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="built_in">memset</span>(Vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(Vis));</span><br><span class="line">            path.<span class="built_in">clear</span>();</span><br><span class="line">            Vis[sx][sy] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dfs</span>(sx,sy,path,<span class="number">0</span>,maxd))<span class="keyword">break</span>;</span><br><span class="line">            Vis[sx][sy] = <span class="number">0</span>;</span><br><span class="line">            maxd++;</span><br><span class="line">        &#125;</span><br><span class="line">        stringstream ss;</span><br><span class="line">        ss&lt;&lt;path;</span><br><span class="line">        output&lt;&lt;ss.<span class="built_in">str</span>()&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>先输入y，再输入x，这题还是很坑的</li>
<li>因为此题要求输出一个较短的路径，以及可能有多解，任意输出一个即可，所以可以使用迭代深搜<ul>
<li>为什么要用迭代深搜呢？因为一旦移动墙，需要改变的状态就会非常多，不太好表示，那怎么进行状态判重呢？干脆不判了，进行一个步数的限制。1步找不到就2步，2步找不到就3步，虽然效率低。</li>
</ul>
</li>
</ul>
<ol start="3">
<li></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,vector&lt;<span class="type">char</span>&gt;&amp; path,<span class="type">int</span> d,<span class="type">const</span> <span class="type">int</span> maxd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isExit</span>(x,y,path))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(d &gt;= maxd)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span>&amp; p = cells[x][y];</span><br><span class="line">    _for(i,<span class="number">0</span>,<span class="number">4</span>)&#123;</span><br><span class="line">        <span class="type">int</span> ax = x + DX[i],ay = y + DY[i];</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">IsValid</span>(ax,ay) || Vis[ax][ay])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span>&amp; np = cells[ax][ay];</span><br><span class="line">        path.<span class="built_in">push_back</span>(DC[i]);</span><br><span class="line">        Vis[ax][ay] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">get</span>(p,i))&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dfs</span>(ax,ay,path,d+<span class="number">1</span>,maxd))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!(<span class="built_in">get</span>(np,i)))&#123;</span><br><span class="line">            _set(p,i,<span class="number">0</span>);</span><br><span class="line">            _set(np,i,<span class="number">1</span>);</span><br><span class="line">            _set(np,REVD[i],<span class="number">0</span>);</span><br><span class="line">            <span class="type">int</span> aax = ax + DX[i],aay = ay + DY[i];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">IsValid</span>(aax,aay))_set(cells[aax][aay],REVD[i],<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dfs</span>(ax,ay,path,d+<span class="number">1</span>,maxd))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">IsValid</span>(aax,aay))_set(cells[aax][aay],REVD[i],<span class="number">0</span>);</span><br><span class="line">            _set(p,i,<span class="number">1</span>);</span><br><span class="line">            _set(np,i,<span class="number">0</span>);</span><br><span class="line">            _set(np,REVD[i],<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Vis[ax][ay] = <span class="number">0</span>;</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果当前这个点就是出口，直接返回true</li>
<li>如果当前的步数超过了限制的步数，返回false</li>
<li>四个方向遍历<ul>
<li>如果下个点非法并且经历过，那么舍弃掉这种情况</li>
<li>如果当前这个点没有此方向的墙，那么直接往下深搜即可，这也不需要比较步数大小了，因为本来就限制好步数了，同层的步数是一样的，所以找到一个答案返回即可</li>
<li>如果有墙，再判断下一个点此方向有没有墙，如果没有，那是可以走的。墙的状态也会发生改变，比如当前点墙的状态需要改变，下一个点的俩个方向墙的状态需要改变，下下个点（如果存在）也有一个方向墙的状态需要改变，最后进行dfs</li>
<li>注意进行下一次dfs时现场的恢复</li>
</ul>
</li>
</ul>
<h3 id="6-Egyptian-Fractions-HARD-version"><a href="#6-Egyptian-Fractions-HARD-version" class="headerlink" title="6.Egyptian Fractions (HARD version)"></a>6.Egyptian Fractions (HARD version)</h3><p>题目链接:<a target="_blank" rel="noopener" href="https://vjudge.net/problem/UVA-12558">Egyptian Fractions (HARD version) - UVA 12558 - Virtual Judge (vjudge.net)</a></p>
<p>解析:</p>
<ol>
<li></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> A,B,K;</span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt; R;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">gcd</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a :<span class="built_in">gcd</span>(b,a % b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">better</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&amp; D,<span class="type">const</span> vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&amp; Ans)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Ans.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">size_t</span> sz = D.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = sz<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>((D[i] != Ans[i]))<span class="keyword">return</span> D[i] &lt; Ans[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">get_first</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b,<span class="type">long</span> <span class="type">long</span> last)</span></span>&#123;</span><br><span class="line">    <span class="comment">//a/b + 1/c = A/B;</span></span><br><span class="line">    <span class="comment">//1/c &lt;= A/B - a/b = (A*b-a*B)/(B*b)</span></span><br><span class="line">    <span class="comment">//c &gt;= (B*b)/(A*b-a*B)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>((B*b) /(A*b-a*B),last+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>gcd（）分子，分母约分时会用到</li>
<li>两个ans经行比较，选越后面的数越小越好</li>
<li>get_first是为取下一项的分母是多少，首先要比前一项多一，其次还要满足不等式</li>
</ul>
<ol start="2">
<li></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b,<span class="type">const</span> <span class="type">int</span> d,<span class="type">const</span> <span class="type">int</span> maxd,vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&amp; D,vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&amp; Ans)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d &gt; maxd)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(a * B &gt; A * b)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(a == A &amp;&amp; b == B)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">better</span>(D,Ans))Ans = D;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> deno = <span class="built_in">get_first</span>(a,b,D.<span class="built_in">empty</span>() ? <span class="number">1LL</span> : D.<span class="built_in">back</span>());</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">//a/b + 1/deno ? A / B</span></span><br><span class="line">        <span class="comment">//a*deno + b / b*deno ? A /B</span></span><br><span class="line">        <span class="comment">//a*deno + b / b*deno &lt; A /B</span></span><br><span class="line">        <span class="comment">//a*deno*B + b*B &lt; A*b*deno</span></span><br><span class="line">        <span class="comment">//最多还能有(maxd-d)个1/deno，但是是绝对小于这个值的</span></span><br><span class="line">        <span class="keyword">if</span>(a*B*deno + (maxd-d)*B*b &lt; A*b*deno)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(!R.<span class="built_in">count</span>(deno))&#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> na = a * deno + b,nb = b * deno,g = <span class="built_in">gcd</span>(na,nb);</span><br><span class="line">            D.<span class="built_in">push_back</span>(deno);</span><br><span class="line">            <span class="built_in">dfs</span>(na /g,nb / g,d+<span class="number">1</span>,maxd,D,Ans);</span><br><span class="line">            D.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        deno++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// streambuf *cinbuf = cin.rdbuf();</span></span><br><span class="line">	<span class="comment">// cin.rdbuf(input.rdbuf());</span></span><br><span class="line">	<span class="type">int</span> T,x;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">1</span>;t &lt;= T;t++)&#123;</span><br><span class="line">        cin&gt;&gt;A&gt;&gt;B&gt;&gt;K;</span><br><span class="line">        R.<span class="built_in">clear</span>();</span><br><span class="line">        _for(i,<span class="number">0</span>,K)&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            R.<span class="built_in">insert</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> maxd = <span class="number">2</span>;maxd &lt;= <span class="number">100</span>;maxd++)&#123;</span><br><span class="line">            vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;D,Ans;</span><br><span class="line">            <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,maxd,D,Ans);</span><br><span class="line">            <span class="keyword">if</span>(!Ans.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                output&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;t&lt;&lt;<span class="string">&quot;: &quot;</span>&lt;&lt;A&lt;&lt;<span class="string">&quot;/&quot;</span>&lt;&lt;B&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                string tail;</span><br><span class="line">                _for(i,<span class="number">0</span>,Ans.<span class="built_in">size</span>())&#123;</span><br><span class="line">                    tail = (i == Ans.<span class="built_in">size</span>()<span class="number">-1</span>)?<span class="string">&quot;\n&quot;</span>:<span class="string">&quot;+&quot;</span>;</span><br><span class="line">                    output&lt;&lt;<span class="string">&quot;1/&quot;</span>&lt;&lt;Ans[i]&lt;&lt;tail;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将禁止使用的数字插入哈希表</li>
<li>依旧采用迭代深搜的方法</li>
<li>dfs<ul>
<li>如果当前超步数，结束</li>
<li>如果当前当前的和是大于要求，结束</li>
<li>如果有符合要求的数据，更新答案，结束</li>
<li>为什么最初的a,b分别是0,1呢？其实只要a&#x2F;b &#x3D; 0都可以的吧？</li>
<li>先拿到此次的分母，一层要dfs多少个呢？首先进行和的判断，如果所有的和是小于所要求的，那么就不必继续</li>
<li>求和，压入答案，深搜，恢复现场</li>
</ul>
</li>
</ul>
<h3 id="7-Digit-Puzzle"><a href="#7-Digit-Puzzle" class="headerlink" title="7.Digit Puzzle"></a>7.Digit Puzzle</h3><p>题目链接:<a target="_blank" rel="noopener" href="https://vjudge.net/problem/UVA-12107">Digit Puzzle - UVA 12107 - Virtual Judge (vjudge.net)</a></p>
<ol>
<li></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Exp</span>&#123;</span><br><span class="line">    string A[<span class="number">3</span>];</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Exp&amp; exp)<span class="type">const</span>&#123;</span><br><span class="line">        _for(i,<span class="number">0</span>,<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">if</span>(A[i] != exp.A[i])</span><br><span class="line">                <span class="keyword">return</span> A[i] &lt; exp.A[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">stringstream&amp; <span class="keyword">operator</span>&lt;&lt;(stringstream&amp; ss,<span class="type">const</span> Exp&amp; ce)&#123;</span><br><span class="line">     ss&lt;&lt;ce.A[<span class="number">0</span>]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ce.A[<span class="number">1</span>]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ce.A[<span class="number">2</span>];</span><br><span class="line">     <span class="keyword">return</span> ss;</span><br><span class="line">&#125;</span><br><span class="line">map&lt;Exp,<span class="type">int</span>&gt;SolCnt;</span><br></pre></td></tr></table></figure>

<ul>
<li>以字典序比较两个Exp的大小</li>
<li>SolCnt记录所有有解的可能出现的谜面</li>
</ul>
<ol start="2">
<li></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每一个位置都有两种决策，要么不变，要么变成*号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfsGen</span><span class="params">(Exp&amp; e,<span class="type">int</span> cur,<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur == <span class="number">3</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">auto</span> back = e.A[cur][pos];</span><br><span class="line">    <span class="type">int</span> nCur = cur + (pos+<span class="number">1</span>)/e.A[cur].<span class="built_in">size</span>(),nPos = (pos+<span class="number">1</span>)%e.A[cur].<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">dfsGen</span>(e,nCur,nPos);</span><br><span class="line">    e.A[cur][pos] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">    ++SolCnt[e];</span><br><span class="line">    <span class="built_in">dfsGen</span>(e,nCur,nPos);</span><br><span class="line">    e.A[cur][pos] = back;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对于每一个等式来说生成的迷面有很多，而且不同的等式可能生成的谜面可能是相等的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">generate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Exp e;</span><br><span class="line">    _for(a,<span class="number">1</span>,<span class="number">100</span>)</span><br><span class="line">        _for(b,<span class="number">1</span>,<span class="number">100</span>)&#123;</span><br><span class="line">            e.A[<span class="number">0</span>] = <span class="built_in">to_string</span>(a),e.A[<span class="number">1</span>] = <span class="built_in">to_string</span>(b),e.A[<span class="number">2</span>] = <span class="built_in">to_string</span>(a*b);</span><br><span class="line">            <span class="built_in">dfsGen</span>(e,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对于每一个从1到100的数字来说，最终都会得到1个等式，以每个等式为基准，生成若干个谜面</li>
</ul>
<ol start="3">
<li></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> string CH = <span class="string">&quot;*0123456789&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> <span class="type">int</span> c,<span class="type">const</span> <span class="type">int</span> maxc,Exp&amp; e,<span class="type">int</span> cur,<span class="type">int</span> pos,<span class="type">bool</span>&amp; found,Exp&amp; ans)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(found &amp;&amp; ans &lt; e)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(SolCnt.<span class="built_in">count</span>(e) &amp;&amp; SolCnt[e] == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!found)found = <span class="literal">true</span>,ans = e;</span><br><span class="line">        <span class="keyword">if</span>(e &lt; ans)ans = e;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cur &gt;= <span class="number">3</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> nCur = cur + (pos + <span class="number">1</span>)/e.A[cur].<span class="built_in">size</span>(),</span><br><span class="line">    nPos = (pos+<span class="number">1</span>)%(e.A[cur].<span class="built_in">size</span>());</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> bk = e.A[cur][pos];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> cd : CH)&#123;</span><br><span class="line">        <span class="keyword">if</span>((cd == <span class="string">&#x27;0&#x27;</span> &amp;&amp; pos == <span class="number">0</span>))<span class="keyword">continue</span>;</span><br><span class="line">        e.A[cur][pos] = cd;</span><br><span class="line">        <span class="type">int</span> nc = c+ (cd != bk);</span><br><span class="line">        <span class="keyword">if</span>(nc &lt;= maxc)<span class="built_in">dfs</span>(nc,maxc,e,nCur,nPos,found,ans);</span><br><span class="line">        e.A[cur][pos] = bk;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// streambuf *cinbuf = cin.rdbuf();</span></span><br><span class="line">	<span class="comment">// cin.rdbuf(input.rdbuf());</span></span><br><span class="line">	<span class="built_in">generate</span>();</span><br><span class="line">    Exp E;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">1</span>;cin&gt;&gt;E.A[<span class="number">0</span>] &amp;&amp; E.A[<span class="number">0</span>] != <span class="string">&quot;0&quot;</span>;t++)&#123;</span><br><span class="line">        cin&gt;&gt;E.A[<span class="number">1</span>]&gt;&gt;E.A[<span class="number">2</span>];</span><br><span class="line">        output&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;t&lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> maxc = <span class="number">0</span>;maxc &lt;= <span class="number">8</span>;maxc++)&#123;</span><br><span class="line">            Exp ce = E,ans;</span><br><span class="line">            <span class="type">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(<span class="number">0</span>,maxc,ce,<span class="number">0</span>,<span class="number">0</span>,found,ans);</span><br><span class="line">            <span class="keyword">if</span>(found)&#123;</span><br><span class="line">                stringstream ss;</span><br><span class="line">                ss&lt;&lt;ans;</span><br><span class="line">                output&lt;&lt;ss.<span class="built_in">str</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        output&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>因为是要修改最少的，所以还是迭代深搜</li>
<li>如果说目前已经找到一个ans，并且当前的e&gt;ans，那么结束搜索（剪枝优化）</li>
<li>如果说找到了一个符合要求的e，那么更新答案</li>
<li>如果目前的cur已经是3，结束搜索（正常结束）</li>
<li>得到下一个要更新的位置，对其尝试11种可能的修改，再往下进行深搜（如果修改的个数没有超过要求修改的个数）</li>
</ul>
<h3 id="8-Cubic-Eight-Puzzle"><a href="#8-Cubic-Eight-Puzzle" class="headerlink" title="8.Cubic Eight-Puzzle"></a>8.Cubic Eight-Puzzle</h3><p>题目链接:<a target="_blank" rel="noopener" href="https://vjudge.net/problem/UVA-1604">Cubic Eight-Puzzle - UVA 1604 - Virtual Judge (vjudge.net)</a></p>
<p>解析:</p>
<ol>
<li></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> string CH = <span class="string">&quot;WRB&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> W = <span class="number">0</span>,R = <span class="number">1</span>,B = <span class="number">2</span>,</span><br><span class="line">DX[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;,DY[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">Pos[<span class="number">6</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">&#123;W,R,B&#125;,&#123;W,B,R&#125;,&#123;B,W,R&#125;,&#123;B,R,W&#125;,&#123;R,W,B&#125;,&#123;R,B,W&#125;</span><br><span class="line">&#125;,</span><br><span class="line">HRoll[<span class="number">6</span>] = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>&#125;,</span><br><span class="line">VRoll[<span class="number">6</span>] = &#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getPose</span><span class="params">(<span class="type">const</span> string&amp; s,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s[<span class="number">3</span>*x+y+<span class="number">1</span>] -<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">setPose</span><span class="params">(string&amp; s,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">    s[<span class="number">3</span>*x+y+<span class="number">1</span>] = pos + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getEmpty</span><span class="params">(<span class="type">const</span> string&amp; s,<span class="type">int</span>&amp; ex,<span class="type">int</span>&amp; ey)</span></span>&#123;</span><br><span class="line">    ex = (s[<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>)/<span class="number">3</span>,ey = (s[<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>)%<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">setEmpty</span><span class="params">(string&amp; s,<span class="type">int</span> ex,<span class="type">int</span> ey)</span></span>&#123;</span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">3</span> * ex + ey + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    s[<span class="number">3</span>*ex + ey + <span class="number">1</span>] = <span class="string">&#x27;7&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> Target[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">H</span><span class="params">(<span class="type">const</span> string&amp; s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>,ex,ey;</span><br><span class="line">    <span class="built_in">getEmpty</span>(s,ex,ey);</span><br><span class="line">    _for(x,<span class="number">0</span>,<span class="number">3</span>)</span><br><span class="line">        _for(y,<span class="number">0</span>,<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="type">char</span> c = (ex == x &amp;&amp; ey == y)?<span class="string">&#x27;E&#x27;</span> :CH.<span class="built_in">at</span>(Pos[<span class="built_in">getPose</span>(s,x,y)][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span>(c != Target[x][y])ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>每个方块涂有三种颜色，对面是相同的颜色</li>
<li>Pos数组记录着方块的6种状态（top,face,right），其中最初是第0种状态</li>
<li>而HRoll 和VRoll分别记录着每种状态水平或垂直翻转能翻转到哪一个状态</li>
<li>getPose得到某一个方块是哪一种姿态,setPose给一个方块设置姿态</li>
<li>getEmpty得到空方块的位置，setEmpty给一个位置设置为空</li>
<li>H函数用于得到现在所有方块和目标方块的状态有多少不同</li>
</ul>
<ol start="2">
<li></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ex,ey;</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;ey&gt;&gt;ex &amp;&amp; ex&amp;&amp; ey)&#123;</span><br><span class="line">	<span class="function">string <span class="title">s</span><span class="params">(<span class="number">10</span>,<span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line">     ex--,ey--;</span><br><span class="line">     <span class="built_in">setEmpty</span>(s,ex,ey);</span><br><span class="line">     <span class="built_in">memset</span>(Target,<span class="number">0</span>,<span class="built_in">sizeof</span>(Target));</span><br><span class="line">     _for(x,<span class="number">0</span>,<span class="number">3</span>)</span><br><span class="line">     	_for(y,<span class="number">0</span>,<span class="number">3</span>)</span><br><span class="line">        	cin&gt;&gt;Target[x][y];</span><br><span class="line">     <span class="type">int</span> ans = <span class="number">32</span>;</span><br><span class="line">     <span class="built_in">dfs</span>(<span class="number">-1</span>,<span class="number">-1</span>,s,<span class="number">0</span>,ans);</span><br><span class="line">     <span class="keyword">if</span>(ans &gt; <span class="number">30</span>)ans = <span class="number">-1</span>;</span><br><span class="line">     output&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>初始化最初的状态，输入目标，进行深搜</li>
</ul>
<ol start="3">
<li></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> paEx,<span class="type">int</span> paEy,<span class="type">const</span> string&amp; s,<span class="type">const</span> <span class="type">int</span> d,<span class="type">int</span>&amp; ans)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> h = <span class="built_in">H</span>(s);</span><br><span class="line">    <span class="keyword">if</span>(h == <span class="number">0</span>)&#123;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans,d);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(h  + d &gt; ans)<span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> ex,ey;</span><br><span class="line">    <span class="built_in">getEmpty</span>(s,ex,ey);</span><br><span class="line">    _for(di,<span class="number">0</span>,<span class="number">4</span>)&#123;</span><br><span class="line">        <span class="type">int</span> ax = ex + DX[di],ay = ey + DY[di];</span><br><span class="line">        <span class="keyword">if</span>(ax &lt; <span class="number">0</span> || ax &gt;= <span class="number">3</span> || ay &lt; <span class="number">0</span> || ay &gt;= <span class="number">3</span>)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(ax == paEx &amp;&amp; ay == paEy)<span class="keyword">continue</span>;</span><br><span class="line">        string ns = s;</span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">getPose</span>(ns,ax,ay);</span><br><span class="line">        <span class="built_in">setEmpty</span>(ns,ax,ay);</span><br><span class="line">        <span class="built_in">setPose</span>(ns,ex,ey,(ax == ex ? HRoll[p]:VRoll[p]));</span><br><span class="line">        <span class="built_in">dfs</span>(ex,ey,ns,d+<span class="number">1</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果现在的状态和目标完全相同，那么更新答案即可</li>
<li>现在和目标不同的个数+已走的步数大于当前最优答案，那么终止搜索（剪枝）</li>
<li>空格的四个方向进行深搜<ul>
<li>新的位置要合法</li>
<li>新的位置不能是上次移动的位置</li>
<li>将新的位置设置为空，设置方块的新姿态，深搜</li>
<li>这里不需要恢复现场因为函数参数除了ans都不是全局的</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/10/13/23-10-13/" data-id="clo0xitgl0001skjdgzxc7i5p" data-title="23.10.13" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9A%B4%E5%8A%9B%E6%90%9C%E7%B4%A2/" rel="tag">暴力搜索</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2023/10/14/23-10-14/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          23.10.14
        
      </div>
    </a>
  
  
    <a href="/2023/10/10/23-10-10/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BF%83%E6%83%85/">心情</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C%E7%9B%98%E6%B8%85%E7%90%86/" rel="tag">C盘清理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E6%9E%90/" rel="tag">分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9A%B4%E5%8A%9B%E6%90%9C%E7%B4%A2/" rel="tag">暴力搜索</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A8%A1%E6%8B%9F/" rel="tag">模拟</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/" rel="tag">算法练习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%AB%98%E6%95%88%E7%AE%97%E6%B3%95/" rel="tag">高效算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%AB%98%E6%95%88%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/" rel="tag">高效算法设计</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C%E7%9B%98%E6%B8%85%E7%90%86/" style="font-size: 10px;">C盘清理</a> <a href="/tags/%E5%88%86%E6%9E%90/" style="font-size: 20px;">分析</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">数据结构</a> <a href="/tags/%E6%9A%B4%E5%8A%9B%E6%90%9C%E7%B4%A2/" style="font-size: 20px;">暴力搜索</a> <a href="/tags/%E6%A8%A1%E6%8B%9F/" style="font-size: 20px;">模拟</a> <a href="/tags/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/" style="font-size: 10px;">算法练习</a> <a href="/tags/%E9%AB%98%E6%95%88%E7%AE%97%E6%B3%95/" style="font-size: 10px;">高效算法</a> <a href="/tags/%E9%AB%98%E6%95%88%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/" style="font-size: 10px;">高效算法设计</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">September 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/10/22/23-10-22/">23.10.22</a>
          </li>
        
          <li>
            <a href="/2023/10/20/23-10-20/">23.10.20</a>
          </li>
        
          <li>
            <a href="/2023/10/19/23-10-19/">23.10.19</a>
          </li>
        
          <li>
            <a href="/2023/10/18/23-10-18/">23.10.18</a>
          </li>
        
          <li>
            <a href="/2023/10/14/23-10-14/">23.10.14</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>